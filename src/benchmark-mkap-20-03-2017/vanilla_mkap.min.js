// std namespace
var std = (function () {

    function is_close(a, b, rel_tol, abs_tol) {

        var diff = Math.abs(a - b);
        if (diff <= abs_tol) {
            return true
        }
        if (Math.abs(a) < Math.abs(b)) {
            return diff <= Math.abs(b) * rel_tol
        }
        else {
            return diff <= Math.abs(a) * rel_tol
        }
    }


    function is_number(obj) {
        return !isNaN(parseFloat(obj))
    }

    function interpolate(start_x, start_y, end_x, end_y, req_x) {
        /**
        Determinates the y-value by interpolation for the given x- and y-values.
        Does also extrapolate
        */

        // Differencte between end point and start point
        var dx = end_x - start_x;
        var dy = end_y - start_y;

        // difference between requested points value and start points value
        var delta_x = req_x - start_x;
        var factor = delta_x / dx;
        var delta_y = factor * dy;

        return start_y + delta_y
    }

    function convergence(lhs, rhs, div) {
        /**Converting by adapting one value by a factor. The factor is determined by the ratio of the left hand side and
         * the right hand side of the equation.
         *
         * Factor: ((Left / Right) - 1) / div + 1
         *
         * @param rhs: {float} Value
         * @param lhs: {float} Value
         *
         * Convergence = lhs *= factor
        */
        // default parameter
        div = (typeof div !== "undefined") ? div: 3;

        var ratio = Math.abs(rhs) / Math.abs(lhs);
        return (ratio - 1) / div + 1
    }

    function convergence_conditions(lhs, rhs, limit_up, limit_lower) {
        // default parameter
        limit_up = (typeof limit_up !== "undefined") ? limit_up : 1.001;
        limit_lower = (typeof limit_lower !== "undefined") ? limit_lower : 0.999;

        var ratio = Math.abs(rhs) / Math.abs(lhs);
        return (limit_lower <= ratio && ratio <= limit_up)
    }

    function nearest_index(arr, x) {
        /* 
        Return the nearest indexes of an array.
        */
        var lower = [];
        var higher = [];

        arr.forEach(function (val) {
            ((val < x) && lower.push(val) || (val > x) && higher.push(val))
        });
        return {"low": arr.indexOf(Math.max.apply(null, lower)), "high": arr.indexOf(Math.min.apply(null, higher))}
    }

    function linspace (a, b, n) {
        if (typeof n === 'undefined') n = Math.max(Math.round(b - a) + 1, 1);
        if (n < 2) {
            return n === 1 ? [a] : []
        }
        var i, ret = Array(n);
        n--;
        for (i = n; i >= 0; i--) {
            ret[i] = (i * b + (n - i) * a) / n
        }
        return ret
    }




    // return from namespace
    return {
        interpolate: interpolate,
        convergence: convergence,
        convergence_conditions: convergence_conditions,
        is_number: is_number,
        nearest_index: nearest_index,
        is_close: is_close,
        linspace: linspace
    }
    
})();  // std namespace



'use strict';

// vector namespace
var vector = (function () {

    var DEBUG = false;

//class
function Point(x, y) {
    this.x = x;
    this.y = y
}

Point.prototype.modulus = function () {
    return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2))
};

Point.prototype.negative = function () {
    return new Point(-this.x, -this.y);
};

Point.prototype.rotate_origin = function (alpha) {
    var radius = this.modulus();
    var alpha0 = this.angle_orgin_x_axis();
    var new_p = new Point(0, 0);
    new_p.displace_polar(alpha + alpha0, radius);
    return new_p
};

Point.prototype.displace_polar = function (alpha, radius) {
    this.x += Math.cos(alpha) * radius;
    this.y += Math.sin(alpha) * radius
};

Point.prototype.angle_orgin_x_axis = function () {
    /**
    Determine the angle between the origin (x-axis=0, z-axis=0) and the point.
    */

    if (this.y == 0) {   // horizontal
        if (this.x > 0) {
            var alpha = 0
        }
        else {
            alpha = Math.PI;
        }
    }
    else if (this.x == 0) { // vertical
        if (this.y > 0) {
            alpha = 0.5 * Math.PI
        }
        else {
            alpha = 1.5 * Math.PI
        }
    }
    else if (this.x > 0 && this.y > 0) {  // quadrant 1
        alpha = Math.atan(Math.abs(this.y / this.x));
    }
    else if (this.x < 0 && 0 < this.y) { // quadrant 2
        alpha = 0.5 * Math.PI + Math.atan(Math.abs(this.x / this.y));
    }
    else if (this.x < 0 && this.y < 0) { // quadrant 3
        alpha = Math.PI + Math.atan(Math.abs(this.y / this.x));
    }
    else if (this.x > 0 && 0 > this.y) { // quadrant 4
        alpha = 1.5 * Math.PI + Math.atan(Math.abs(this.x / this.y));
    }
    else {
        if (DEBUG) {
            console.log("Can not determine the angle of the point with the axes origin")
        }
    }

    return alpha
};





//end class


function interpolate_points(start_p, end_p, req_p) {
    /// <param name="start_p" type="Object from Point class">reference value that should be interpolated between</param>
    /// <param name="end_p" type="Object from Point class">reference value that should be interpolated between</param>
    /// <param name="req_p" type="Object from Point class">Value that is requested. x or y of the object should be null, on the request time.</param>

    // Differencte between end point and start point
    var d_x = end_p.x - start_p.x;
    var d_y = end_p.y - start_p.y;

    if (req_p.y == null) {
        // difference between requested points value and start points value
        var delta_x = req_p.x - start_p.x;

        var factor = delta_x / d_x;
        var delta_y = d_y * factor;
    }
    else if (req_p.x == null) {
        delta_y = req_p.y - start_p.y;

        factor = delta_y / d_y;
        delta_x = d_x * factor;
    }

    return new Point(start_p.x + delta_x, start_p.y + delta_y);
}


function lowest_point(point_1, point_2, axis) {
    /// Returns the lowest point
    /// <param name="axis" type="String">axis, x or y</param>
    if (axis == 'x') {
        if (point_1.x < point_2.x) {
            return point_1;
        }
        else if (point_2.x < point_1.x) {
            return point_2;
        }
        else {
            console.log("points x values are identical")
        }
    }
    else if (axis == 'y') {
        if (point_1.y < point_2.y) {
            return point_1;
        }
        else if (point_2.y < point_1.y) {
            return point_2;
        }
        else {
            return new Point(null, point_1.y)
        }
    }

    console.log("cannot verify given axis")
}

function heighest_point(point_1, point_2, axis) {
    /// Returns the heighest point
    /// <param name="axis" type="String">axis, x or y</param>


    return lowest_point(point_1.negative(), point_2.negative(), axis).negative()
}

return {
    interpolate_points: interpolate_points,
    Point: Point,
    highest_point: heighest_point,
    lowest_point: lowest_point


}

})();  // vector namespace
'use strict';

// crsn namespace
var crsn = (function () {

function PolyGon(point_list) {
    /// <param name="point_list" type="array">Array with objects from the Point class representing the polygons coordinates</param>
    this.point_list = point_list;
    this.n_value = 1000;
    this.subtractor = null;
    this.instantiate()
}

PolyGon.prototype.activate_subtractor = function() {
        this.subtractor.merge_width(this)
    };

PolyGon.prototype.instantiate = function () {
    this.top = this.highest_point('y').y;
    this.bottom = this.lowest_point('y').y;
    // all the values on the y-axis
    this.y_val = this.det_height_array();

    // x_val array has arrays in it representing the results per y_values increment on the y-axis. In these inner arrays are the x-values paired, representing the solid boundaries.
    this.paired_xvals = [];
    this.width_array = [];
    this.return_x_on_axis();
    };

PolyGon.prototype.det_height_array = function () {
    return std.linspace(0, this.top, this.n_value)
};

PolyGon.prototype.lowest_point = function (axis) {
    /// Find the lowest point on a give axis. 
    /// <param name="axis" type="String">axis, x or y</param>

    var low = this.point_list[0];
    
    for (var i = 1; i < this.point_list.length; i++) {
        low = vector.lowest_point(low, this.point_list[i], axis)
    }
    return low
};

PolyGon.prototype.highest_point = function (axis) {
    var height = this.point_list[0];

    for (var i = 1; i < this.point_list.length; i++) {
        height = vector.highest_point(height, this.point_list[i], axis)
    }
    return height
};


PolyGon.prototype.return_x_on_axis = function () {
    /**
    Method for defining the x values of the sections part that hit the polygon sides.
    The y axis is incremented. And with each step the x-axis on this y-value are determined.
    Two x-values means a closed cross section on that y-value. Three or more x-values indicate that
    there is a void in the cross section.


    x1  x2  x3  x4
    _____   _____            y
    |   |   |   |           |
    |   |   |   |           |
    |   |___|   |           |          x
    |___________|           ---------->

     */

    for (var i = 0; i < this.y_val.length; i++) {
        /** increment a value on the y-axis and search the coordinates of the polygon for crossing edges.
         An edge crosses the x-axis on this y-values height if one coordinate is above and the subsequent/previous
        coordinate is underneath the y-value.
        */

        var y = this.y_val[i] - this.y_val[1] * 0.5;

        // the x_values that intersect the polygon on this y increment.
        var x_vals = [];

        // iterate through the coordinates
        for (var a = 0; a < this.point_list.length - 1; a++) {
            // y-value is between point at index a and point at index a + 1
            if ((this.point_list[a].y >= y) == !(this.point_list[a + 1].y >= y)) {

                var interpolated_point = vector.interpolate_points(this.point_list[a], this.point_list[a + 1],
                    new vector.Point(null, y));
                x_vals.push(interpolated_point.x);
            }
        }
        // switch the last index to the front
        x_vals.sort(function (a, b) { return a - b });
        // x_vals contains the x-values. x1 and x2 is solid, x2 and x3 is void, x3 and x4 is solid etc.
        // Pair the solid x-values like so: [[x1, x2], [x3, x4]]

        var paired_x_vals = [];
        for (var x = 0; x < x_vals.length; x++) {
            if ((x + 1) % 2 == 0) {
                paired_x_vals.push([x_vals[x - 1], x_vals[x]])
            }
        }
        this.paired_xvals.push(paired_x_vals);

        // determine the full width on this y-value by summing the dx in the paired lists.
        var width = 0;
        for (a = 0; a < paired_x_vals.length; a++) {
            width += paired_x_vals[a][1] - paired_x_vals[a][0]
        }
        this.width_array.push(Math.abs(width));
    }
};


PolyGon.prototype.area = function () {
    var dy = this.y_val[1] ;
    var area = 0;
    for (var i = 0; i < this.y_val.length; i++) {
        area += dy * this.width_array[i]
    }
    area = Math.round(area) ;
    return Math.abs(area)
};

PolyGon.prototype.zero_line = function () {
    var dh = (this.top - this.bottom) / this.n_value;
    var sum_A_h = 0;
    for (var i in this.width_array) {
        sum_A_h += dh * this.width_array[i] * this.y_val[i]
    }
    return sum_A_h / this.area()
};

// end class


    function Circle(radius) {
        var n = 100;
        var alpha0 = Math.PI * 2 / n;
        var pl = [];
        var p0 = new vector.Point(0, -radius);
        // translation point. Does nothing else
        var p_set = new vector.Point(radius, radius);
        for (var i = 1; i <= n; i++) {
            var alpha = alpha0 * i;
            
            var p = p0.rotate_origin(alpha);
            p = new vector.Point(p.x + p_set.x, p.y + p_set.y);
          
            pl.push(p)
        }

        PolyGon.call(this, pl);  // call super constructor
    }

    Circle.prototype = Object.create(PolyGon.prototype);
    Circle.prototype.constructor = Circle;

    function Subtractor(top, point_list, n_value) {
        /**
         * @param top (float) Top of the parent cross section (y-value)
         * @param n_value (int) Amount of section in the parent cross section
         */
        this.point_list = point_list;
        this.paired_xvals = [];
        this.width_array = [];
        this.top = top;
        this.n_value = n_value;
        this.y_val = this.det_height_array();
        this.return_x_on_axis();

    }

    Subtractor.prototype.merge_width = function (parent) {
        /**
         * @param parent Object from the parent cross section.
         */

        for (var i in parent.width_array) {
            parent.width_array[i] -= this.width_array[i];

            // merge the paired x_vals (for the plotter)
            var x_vals = [];
            if (this.width_array[i] > 0) {

                //unpack parents paired x_vals
                for (var j in parent.paired_xvals[i]) {
                    x_vals.push(parent.paired_xvals[i][j][0]);
                    x_vals.push(parent.paired_xvals[i][j][1])
                }
                // unpack subtractors paired x_vals
                for (j in this.paired_xvals[i]) {
                    x_vals.push(this.paired_xvals[i][j][0]);
                    x_vals.push(this.paired_xvals[i][j][1])
                }

                x_vals.sort(function (a, b) { return a - b });
                // repack them
                var paired_x_vals = [];
                for (var x = 0; x < x_vals.length; x++) {
                    if ((x + 1) % 2 == 0) {
                        paired_x_vals.push([x_vals[x - 1], x_vals[x]])
                    }
                }
                parent.paired_xvals[i] = paired_x_vals
            }
        }
    };

    Subtractor.prototype.return_x_on_axis = PolyGon.prototype.return_x_on_axis;
    Subtractor.prototype.det_height_array = PolyGon.prototype.det_height_array;


    function Tube(radius_out, radius_in) {
        var n = 100;
        var alpha0 = Math.PI * 2 / n;
        var pl_out = [];
        var pl_in = [];
        var p0_out = new vector.Point(0, -radius_out);
        var p0_in = new vector.Point(0, -radius_in);

        // Translation points. Do nothing else
        var p_set_in = new vector.Point(radius_out, radius_out);
        var p_set_out = new vector.Point(radius_out, radius_out);

        for (var i = 1; i <= n + 1; i++) {
            var alpha = alpha0 * i;
            var p_out = p0_out.rotate_origin(alpha);
            p_out = new vector.Point(p_out.x + p_set_out.x, p_out.y + p_set_out.y);
            var p_in = p0_in.rotate_origin(alpha);
            p_in = new vector.Point(p_in.x + p_set_in.x, p_in.y + p_set_in.y);

            pl_out.push(p_out);
            pl_in.push(p_in);
        }
        PolyGon.call(this, pl_out);

        this.subtractor = new Subtractor(radius_out * 2, pl_in, this.n_value);
        this.subtractor.merge_width(this)
    }

    Tube.prototype = Object.create(PolyGon.prototype);
    Tube.prototype.constructor = Tube;




// return from namespace
return {
    PolyGon: PolyGon,
    Circle: Circle,
    Tube: Tube,
    Subtractor: Subtractor
}
    
})();  // crsn namespace
'use strict';
var DEBUG = false;
// mkap namespace
var mkap = (function () {

    //class
    function MomentKappa(cross_section, compressive_diagram, tensile_diagram) {
        this.cross_section = cross_section;
        this.compressive_diagram = compressive_diagram;
        this.tensile_diagram = tensile_diagram;
        // sum of the forces in the cross section
        this.force_tensile = 0;
        this.force_compression = 0;
        this.normal_force = 0;
        this.iterations = 50;
        this.div = 2;

        /*
        * Reinforcement.
        * For n layers of reinforcement, n parameters need to be initiated in the arrays.
        */
        this.rebar_As = [];
        // distance rebar from the bottom of the master cross section
        this.rebar_z = [];
        // objects from the StressStrain class
        this.rebar_diagram = [];
        // phased rebar
        this.m0 = [];
        this.rebar_strain0_plt = [];
        this.rebar_diam = null;  // for the plotter

        // Applied at t=0. 'werkvoorspanning'
        this.prestress = [];

        // Stress and strain in the reinforcement after Mp has been applied and the deformation is zero.
        this.d_stress = [];
        this.d_strain = [];
        this.mp = 0;
        // Used by session.js when prestress is applied.
        this.original_rebar_diagrams = [];

    
        /**
        results
        */
        this.solution = null;
        this.rebar_force = [];
        this.rebar_strain = [];
        this.stress = [];
        this.moment = null;
        this.kappa = null;
        this.strain_top = null;
        this.strain_btm = null;
        this.zero_line = null ; // xu is height - zero line
        this.xu = null;

        this.reduce_rebar = false

    }

    MomentKappa.prototype.det_force_distribution = function (strain_top, strain_btm, reduce_rebar) {
        /**
         * Sum the tensile and compression forces based on the strain distribution
         *
         * @param strain_top: (float) Strain at the top of the cross section.
         * @param strain_btm: (float) Strain at the bottom of the cross section.
         * @param reduce_rebar: (bool) Subtract the reinforcement cross section of the whole cross section.
         *
         */
        this.force_compression = 0;
        this.force_tensile = 0;
        this.stress = [];
        this.rebar_strain = [];
        this.strain_top = strain_top;
        this.strain_btm = strain_btm;

        // default parameter
        reduce_rebar = (typeof reduce_rebar !== "undefined") ? reduce_rebar : false;
        this.reduce_rebar = reduce_rebar;

        if (this.normal_force < 0) {
            this.force_tensile += Math.abs(this.normal_force)
        }
        else {
            this.force_compression += Math.abs(this.normal_force)
        }

        // height of the sections
        var dh = this.cross_section.y_val[1];

        //cross section
        var crs_btm = this.cross_section.y_val[0];
        var crs_top = this.cross_section.y_val[this.cross_section.y_val.length - 1];

        // iterate over the y-axis of the master cross section and determine the stresses.
        // y-axis starts at bottom.
        for (var i = 0; i < this.cross_section.y_val.length; i++) {

            // interpolate the strain at this y-value
            var strain_y = std.interpolate(crs_btm, strain_btm,
                crs_top, strain_top, this.cross_section.y_val[i]);
        

            // Send the strain value as parameter in the stress strain diagram
            if (strain_y < 0) {
                stress = -this.compressive_diagram.det_stress(Math.abs(strain_y));
                this.force_compression -= stress * this.cross_section.width_array[i] * dh

            }

            else {
                stress = this.tensile_diagram.det_stress(strain_y);
                this.force_tensile += stress* this.cross_section.width_array[i] * dh
            }
            this.stress.push(stress)
        }

    
        // determine reinforcement forces
        this.rebar_force = [];
        for (i = 0; i < this.rebar_As.length; i++) {
            var strain = std.interpolate(crs_btm, strain_btm, crs_top, strain_top, this.rebar_z[i]);
            this.rebar_strain.push(strain + this.d_strain[i]);

            var stress = this.rebar_diagram[i].det_stress(Math.abs(strain));

            // absolute value
            var force = this.rebar_As[i] * stress;
        
            var stress_reduct;
            if (strain < 0 && this.prestress[i] == 0) {
                this.force_compression += force;
                this.rebar_force.push(-force);

                if (reduce_rebar) {
                    // Subtract reinforcement area from master element
                    stress_reduct = this.compressive_diagram.det_stress(Math.abs(strain));
                    this.force_compression -= this.rebar_As[i] * stress_reduct
                }
            }
            else {
                this.force_tensile += force;
                this.rebar_force.push(force);

                if (reduce_rebar) {
                    // Subtract reinforcement area from master element
                    stress_reduct = this.tensile_diagram.det_stress(strain);
                    this.force_tensile -= this.rebar_As[i] * stress_reduct
                }
            }
        }

    };

    MomentKappa.prototype.set_div = function(str) {
        /**
         * Up the allowed iterations at small strains. Due to asymptotic behaviour there are more iterations needed.
         *
         * @param str: (float) Strain.
         */
        if (Math.abs(str) < 0.15) {
            this.iterations = 200
        }
        else {
            this.iterations = 250;
        }
    };

    MomentKappa.prototype.iterator_top_constant = function (btm_str, top_str) {
        /**
         * @param btm_str: (float) strain to start
         * @param top_str: (float) strain to start
         */

        // If the reinforcement is above the zero line, there will sometimes be no tensile force
        // Find the index of the highest reinforcement layer.
        var top_reinf = Math.min.apply(null, this.rebar_z);
        for (var i = 0; i < this.rebar_As.length; i++) {
            if (this.rebar_z[i] == top_reinf) {
                var rbr_index = i
            }
        }

        var div = this.div;
        var fHistoryHigh = 1e12;
        var fHistoryLow = -1e12;
        var count = 0;
        var offset = this.compressive_diagram.strain[this.compressive_diagram.strain.length - 1];
        // iterate until the convergence criteria is met
        while (1) {
            if (std.convergence_conditions(this.force_compression, this.force_tensile)) {
                this.solution = true;
                if (false) {
                    console.log("convergence after %s iterations".replace("%s", count))
                }

                return [0, count]; // [success, count]
            }

            // Extrapolate the strain from the first significant rebar strain point, to the bottom strain.
            // Needed when the rebar is above the neutral line.
            else if (isNaN(this.force_tensile) || this.force_tensile == 0) {
                btm_str = std.interpolate(this.cross_section.top, top_str, top_reinf, this.rebar_diagram[rbr_index].strain[1], this.cross_section.bottom)
                + offset

            }

            else if (this.force_tensile > 0) {
                var factor = std.convergence(this.force_tensile, this.force_compression, div);
                btm_str = btm_str * factor;
            }

            this.det_force_distribution(top_str, btm_str - offset);
            if (count > this.iterations) {
                if (false) {
                    console.log("no convergence found after %s iterations".replace("%s", count))
                }
                return [1, count];

            }
            count += 1;

            // Adaptive convergence divider
            // Change the division based on the factor history
            if (factor > 1) {
                if (factor > fHistoryHigh) {
                    div++
                }
                fHistoryHigh = factor;
            }
            else {
                if (factor < fHistoryLow) {
                    div++
                }
                fHistoryLow = factor
            }
        }
    };

    MomentKappa.prototype.iterator_btm_constant = function (btm_str, top_str) {
        /**
         * @param btm_str: (float) strain to start
         * @param top_str: (float) strain to start
         */
        var div = this.div;
        var fHistoryHigh = 1e12;
        var fHistoryLow = -1e12;
        var count = 0;
        var offset = this.compressive_diagram.strain[this.compressive_diagram.strain.length - 1];
        // iterate until the convergence criteria is met
        while (1) {
            if (std.convergence_conditions(this.force_compression, this.force_tensile)) {
                this.solution = true;

                if (false) {
                    console.log("convergence after %s iterations".replace("%s", count))
                }
                return [0, count]
            }

            var factor = std.convergence(this.force_compression, this.force_tensile, this.div);
            top_str = top_str * factor;

            this.det_force_distribution(top_str - offset, btm_str);

            if (count > this.iterations) {
                if (false) {
                    console.log("no convergence found after %s iterations".replace("%s", count))
                }
                return [1, count]
            }
            count += 1;

            // Adaptive convergence divider
            // Change the division based on the factor history
            if (factor > 1) {
                if (factor > fHistoryHigh) {
                    div++
                }
                fHistoryHigh = factor;
            }
            else {
                if (factor < fHistoryLow) {
                    div++
                }
                fHistoryLow = factor
            }
        }
    };

    MomentKappa.prototype.iterator_complete_pressure = function (top_str) {
        /**
         * Compression in bottom may not be higher than in top.
         */

        var btm_str = top_str;

        this.det_force_distribution(top_str, btm_str);
        if (this.force_tensile > this.force_compression) {
            // No equilibrium possible with positive kappa.
            return 1
        }

        var count = 0;
        // iterate until the convergence criteria is met

        var div = this.div;
        var fHistoryHigh = 1e12;
        var fHistoryLow = -1e12;
        var offset = this.compressive_diagram.strain[this.compressive_diagram.strain.length - 1];
        while (1) {
            if (std.convergence_conditions(this.force_compression, this.force_tensile)) {
                this.solution = true;

                if (false) {
                    console.log("convergence after %s iterations".replace("%s", count))
                }
                return [0, count]
            }

            var factor = std.convergence(this.force_compression, this.force_tensile, div);
            btm_str = btm_str * factor;

            this.det_force_distribution(top_str, btm_str - offset);

            if (count > this.iterations) {

                if (false) {
                    console.log("no convergence found after %s iterations".replace("%s", count))
                }
                return [1, count]
            }
            count += 1;
            // Adaptive convergence divider
            // Change the division based on the factor history
            if (factor > 1) {
                if (factor > fHistoryHigh) {
                    div++
                }
                fHistoryHigh = factor;
            }
            else {
                if (factor < fHistoryLow) {
                    div++
                }
                fHistoryLow = factor
            }
        }
    };


    MomentKappa.prototype.solver = function (strain_top, strain) {
        /**
         * Return the .det_stress method several times and adapt the input until the convergence criteria is met.
         *
         * @param strain_top: (bool) Constant strain at the top. If true, the strain at the top will remain constant
         *                      and the strain at the bottom will be iterated over. If false vice versa for strain_bottom.
         * @param strain: (float) Constant strain at the top or bottom.
         */

        // default parameter
        strain_top = (typeof strain_top !== "undefined") ? strain_top : true;

        this.solution = false;
        var total_iter = 0;

        // first iteration
        var btm_str = strain;
        var top_str = -strain;
        this.det_force_distribution(top_str, btm_str);

        // If the axial force is substantial start with a solver completely under pressure.
        var a = this.compressive_diagram.det_stress(-top_str) * this.cross_section.area() * 0.75;
        if (-this.normal_force > a) {
                /**
                 * Try to solve for a cross section completely under pressure.
                 */
                sol = this.iterator_complete_pressure(top_str);
                if (sol[0] === 0) {
                    return sol[1]
                }
                else {
                    total_iter += sol[1];

                    if (strain_top) {  // top strain remains constant
                        var sol = this.iterator_top_constant(btm_str, top_str);
                        if (sol[0] === 0) {
                            return sol[1]
                        }
                        else {
                            total_iter += sol[1]
                        }
                    }
                    else { // bottom strain remains constant
                        sol = this.iterator_btm_constant(btm_str, top_str);
                        if (sol[0] === 0) {
                            return sol[1]
                        }
                        else {
                            total_iter += sol[1]
                        }
                    }

                }
        }
        // Standard control flow
        else {
            console.log("Standard first");
            if (strain_top) {  // top strain remains constant
                var sol = this.iterator_top_constant(btm_str, top_str);
                if (sol[0] === 0) {
                    return sol[1]
                }
                else {
                    total_iter += sol[1]
                }
            }
            else { // bottom strain remains constant
                sol = this.iterator_btm_constant(btm_str, top_str);
                if (sol[0] === 0) {
                    return sol[1]
                }
                else {
                    total_iter += sol[1]
                }
            }

            if (!this.validity() && this.normal_force != 0) {
                /**
                 * Try to solve for a cross section completely under pressure.
                 */
                console.log("complete pressure")
                sol = this.iterator_complete_pressure(top_str);
                if (sol[0] === 0) {
                    return sol[1]
                }
                else {
                    total_iter += sol[1]
                }
            }
        }
        return total_iter
    };

    MomentKappa.prototype.det_m_kappa = function () {
        /**
        Determines the moment and kappa values.
    
        For each sections center of gravity the moment around the origin is determined.
    
    
        ______     <---- - F compression 
        |     |         
        |     |                           |y
        |     |                           |
        |_____|    ----> + F tensile      |0____x
        
        */

        // center of gravity offset of a section
        this.kappa = (-this.strain_top + this.strain_btm) / (this.cross_section.top - this.cross_section.bottom);
        this.moment = this.mp;
        var offset = this.cross_section.y_val[1] * 0.5;

        // height of the sections
        var dh = this.cross_section.y_val[1];

        for (var i = 0; i < this.cross_section.y_val.length; i++) {
            var arm = this.cross_section.y_val[i] + offset;
            var force = this.stress[i] * this.cross_section.width_array[i] * dh;
       
            this.moment += arm * force;
        }

        // N normal force share
        this.moment -= this.normal_force * this.cross_section.zero_line();

        // rebar share
        for (i = 0; i < this.rebar_As.length; i++) {
            this.moment += this.rebar_force[i] * this.rebar_z[i];

            // reduction of master cross section at place of rebar
            if (this.reduce_rebar) {
                if (this.rebar_force[i] > 0) {  // tensile stress
                    var stress_reduct = this.tensile_diagram.det_stress(this.rebar_strain[i]);
                    //this.moment -= stress_reduct * this.rebar_As[i] * this.rebar_z[i]
                }
                else {  // compression stress
                    stress_reduct = -this.compressive_diagram.det_stress(Math.abs(this.rebar_strain[i]));
                    //this.moment -= stress_reduct * this.rebar_As[i] * this.rebar_z[i]
                }
            }
        }

        this.moment *= -1;
        // zero line
        this.zero_line = std.interpolate(this.strain_btm, this.cross_section.bottom, this.strain_top, this.cross_section.top, 0);
        this.xu = this.cross_section.top - this.zero_line
    };

    MomentKappa.prototype.validity = function () {
        /**
         * Check if the found equilibrium solution could be regarded as valid.
         *
         * @type {boolean}
         */
        var valid = true;
        if (std.is_number(this.moment)
            && std.is_number(this.kappa)
            && this.solution
            && this.strain_top >= -this.compressive_diagram.strain[this.compressive_diagram.strain.length - 1]
            && this.strain_top < 0
            ) {
            for (var i in this.rebar_strain) {
                if (Math.abs(this.rebar_strain[i]) > Math.max.apply(null, this.rebar_diagram[i].strain)) {
                    valid = false;
                }
            }

            if (std.is_close(this.strain_btm, 0, 0.01, 0.01)) {
                if (this.xu >= (this.cross_section.top - this.cross_section.bottom)) {
                    return false
                }
            }
            }

        else {
            valid = false;
        }
        return valid
    };

    MomentKappa.prototype.instantiate_standard_reinforcement = function(As, rebar_z, rebar_diagram) {
        /**
         * Instantiate standard moment kappa solver. Because of the extra options regarding phased moments, prestress
         * etc. some extra parameters need to be instantiated.
         *
         * @param As: {Array} Area of the reinforcement per layer.
         * @param rebar_z: {Array} Height of the reinforcement layer with respect to the bottom of the cross section.
         * @param rebar_diagram: {StressStrain} Diagram object.
         */

        this.rebar_z = rebar_z;
        this.rebar_As = As;

        this.prestress = this.m0 = this.d_stress = this.d_strain =
            Array.apply(null, Array(As.length)).map(Number.prototype.valueOf, 0);

        this.rebar_diagram = Array.apply(null, Array(As.length)).map(function () {
            return rebar_diagram
        });

    };



    function StressStrain(strain, stress) {
        /**
         * Class for creating stress strain diagrams.
         *
         * @param strain: (array) Strain values of the diagram.
         * @param stress: (array) Stress values of the diagram.
        */

        this.strain = strain;
        this.stress = stress
    }


    StressStrain.prototype.det_stress = function (strain) {
        /**
         * @param strain: (float) Strain for which the stress needs to be determined.
         * Iterate through the strain array until iterated value exceeds the requested strain.
         * At that the point the two values will interpolated.
         */

        for (var i = 0; i < this.strain.length; i++) {
            if (strain > this.strain[this.strain.length - 1]) {
                return 0;
            }
            else if (this.strain[i] == strain) {
                return this.stress[i]
            }
            else if (this.strain[i] > strain) {
                return std.interpolate(this.strain[i - 1], this.stress[i - 1],
                    this.strain[i], this.stress[i], strain);
            }
        }
    };

    StressStrain.prototype.det_strain = function (stress) {
        /**
         * @param stress: (float) Strain for which the stress needs to be determined.
         * Iterate through the stress array until iterated value exceeds the requested strain.
         * At that the point the two values will interpolated.
         */
        for (var i = 0; i < this.stress.length; i++) {
            if (stress > this.stress[this.stress.length - 1]) {
                return 0;
            }
            else if (this.stress[i] == stress) {
                return this.strain[i]
            }
            else if (this.stress[i] > stress) {
                return std.interpolate(this.stress[i - 1], this.strain[i - 1],
                    this.stress[i], this.strain[i], stress);
            }
        }
    };

    function calcHookup (reduction, mkap, top) {
        /**
         * Reduction factor (float)
         *
         * Starts the calculation with the latest point of the compression material and reduces it until a solution is found.
         * Returns the strain that resulted in a valid solution.
         *
         * @param reduction: {float} the reduction factor of the strain.
         * @param mkap: {object} from the MomentKappa class.
         * @param top: {bool} Depends if the hookup is sought for the top or the bottom of the cross section.
         */
        top = (typeof top !== "undefined") ? top : true;
        var strain;
        if (top) {
            strain = mkap.compressive_diagram.strain[mkap.compressive_diagram.strain.length - 1];
        }
        else {
            strain = mkap.tensile_diagram.strain[mkap.tensile_diagram.strain.length - 1];
        }

        mkap.solver(top, strain);
        mkap.det_m_kappa();


        var count = 0;
        while (!mkap.validity() && count < 150) {
            mkap.solver(top, strain);
            mkap.det_m_kappa();
            strain *= (1 - reduction);
            count += 1;
        }
        return strain
    }


    return {    MomentKappa: MomentKappa,
                StressStrain: StressStrain,
                calcHookup: calcHookup
    }

})();  // mkap namespace

module.exports = {
    std: std,
    mkap: mkap,
    vector: vector,
    crsn: crsn
}