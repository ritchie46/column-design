/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* unknown exports provided */
/* all exports used */
/*!*********************************!*\
  !*** ./src/vanilla_mkap.min.js ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// std namespace\nvar std = function () {\n\n    function is_close(a, b, rel_tol, abs_tol) {\n\n        var diff = Math.abs(a - b);\n        if (diff <= abs_tol) {\n            return true;\n        }\n        if (Math.abs(a) < Math.abs(b)) {\n            return diff <= Math.abs(b) * rel_tol;\n        } else {\n            return diff <= Math.abs(a) * rel_tol;\n        }\n    }\n\n    function is_number(obj) {\n        return !isNaN(parseFloat(obj));\n    }\n\n    function interpolate(start_x, start_y, end_x, end_y, req_x) {\n        /**\r\n        Determinates the y-value by interpolation for the given x- and y-values.\r\n        Does also extrapolate\r\n        */\n\n        // Differencte between end point and start point\n        var dx = end_x - start_x;\n        var dy = end_y - start_y;\n\n        // difference between requested points value and start points value\n        var delta_x = req_x - start_x;\n        var factor = delta_x / dx;\n        var delta_y = factor * dy;\n\n        return start_y + delta_y;\n    }\n\n    function convergence(lhs, rhs, div) {\n        /**Converting by adapting one value by a factor. The factor is determined by the ratio of the left hand side and\r\n         * the right hand side of the equation.\r\n         *\r\n         * Factor: ((Left / Right) - 1) / div + 1\r\n         *\r\n         * @param rhs: {float} Value\r\n         * @param lhs: {float} Value\r\n         *\r\n         * Convergence = lhs *= factor\r\n        */\n        // default parameter\n        div = typeof div !== \"undefined\" ? div : 3;\n\n        var ratio = Math.abs(rhs) / Math.abs(lhs);\n        return (ratio - 1) / div + 1;\n    }\n\n    function convergence_conditions(lhs, rhs, limit_up, limit_lower) {\n        // default parameter\n        limit_up = typeof limit_up !== \"undefined\" ? limit_up : 1.001;\n        limit_lower = typeof limit_lower !== \"undefined\" ? limit_lower : 0.999;\n\n        var ratio = Math.abs(rhs) / Math.abs(lhs);\n        return limit_lower <= ratio && ratio <= limit_up;\n    }\n\n    function nearest_index(arr, x) {\n        /* \r\n        Return the nearest indexes of an array.\r\n        */\n        var lower = [];\n        var higher = [];\n\n        arr.forEach(function (val) {\n            val < x && lower.push(val) || val > x && higher.push(val);\n        });\n        return { \"low\": arr.indexOf(Math.max.apply(null, lower)), \"high\": arr.indexOf(Math.min.apply(null, higher)) };\n    }\n\n    function linspace(a, b, n) {\n        if (typeof n === 'undefined') n = Math.max(Math.round(b - a) + 1, 1);\n        if (n < 2) {\n            return n === 1 ? [a] : [];\n        }\n        var i,\n            ret = Array(n);\n        n--;\n        for (i = n; i >= 0; i--) {\n            ret[i] = (i * b + (n - i) * a) / n;\n        }\n        return ret;\n    }\n\n    // return from namespace\n    return {\n        interpolate: interpolate,\n        convergence: convergence,\n        convergence_conditions: convergence_conditions,\n        is_number: is_number,\n        nearest_index: nearest_index,\n        is_close: is_close,\n        linspace: linspace\n    };\n}(); // std namespace\n\n\n'use strict';\n\n// vector namespace\nvar vector = function () {\n\n    var DEBUG = false;\n\n    //class\n    function Point(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    Point.prototype.modulus = function () {\n        return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));\n    };\n\n    Point.prototype.negative = function () {\n        return new Point(-this.x, -this.y);\n    };\n\n    Point.prototype.rotate_origin = function (alpha) {\n        var radius = this.modulus();\n        var alpha0 = this.angle_orgin_x_axis();\n        var new_p = new Point(0, 0);\n        new_p.displace_polar(alpha + alpha0, radius);\n        return new_p;\n    };\n\n    Point.prototype.displace_polar = function (alpha, radius) {\n        this.x += Math.cos(alpha) * radius;\n        this.y += Math.sin(alpha) * radius;\n    };\n\n    Point.prototype.angle_orgin_x_axis = function () {\n        /**\r\n        Determine the angle between the origin (x-axis=0, z-axis=0) and the point.\r\n        */\n\n        if (this.y == 0) {\n            // horizontal\n            if (this.x > 0) {\n                var alpha = 0;\n            } else {\n                alpha = Math.PI;\n            }\n        } else if (this.x == 0) {\n            // vertical\n            if (this.y > 0) {\n                alpha = 0.5 * Math.PI;\n            } else {\n                alpha = 1.5 * Math.PI;\n            }\n        } else if (this.x > 0 && this.y > 0) {\n            // quadrant 1\n            alpha = Math.atan(Math.abs(this.y / this.x));\n        } else if (this.x < 0 && 0 < this.y) {\n            // quadrant 2\n            alpha = 0.5 * Math.PI + Math.atan(Math.abs(this.x / this.y));\n        } else if (this.x < 0 && this.y < 0) {\n            // quadrant 3\n            alpha = Math.PI + Math.atan(Math.abs(this.y / this.x));\n        } else if (this.x > 0 && 0 > this.y) {\n            // quadrant 4\n            alpha = 1.5 * Math.PI + Math.atan(Math.abs(this.x / this.y));\n        } else {\n            if (DEBUG) {\n                console.log(\"Can not determine the angle of the point with the axes origin\");\n            }\n        }\n\n        return alpha;\n    };\n\n    //end class\n\n\n    function interpolate_points(start_p, end_p, req_p) {\n        /// <param name=\"start_p\" type=\"Object from Point class\">reference value that should be interpolated between</param>\n        /// <param name=\"end_p\" type=\"Object from Point class\">reference value that should be interpolated between</param>\n        /// <param name=\"req_p\" type=\"Object from Point class\">Value that is requested. x or y of the object should be null, on the request time.</param>\n\n        // Differencte between end point and start point\n        var d_x = end_p.x - start_p.x;\n        var d_y = end_p.y - start_p.y;\n\n        if (req_p.y == null) {\n            // difference between requested points value and start points value\n            var delta_x = req_p.x - start_p.x;\n\n            var factor = delta_x / d_x;\n            var delta_y = d_y * factor;\n        } else if (req_p.x == null) {\n            delta_y = req_p.y - start_p.y;\n\n            factor = delta_y / d_y;\n            delta_x = d_x * factor;\n        }\n\n        return new Point(start_p.x + delta_x, start_p.y + delta_y);\n    }\n\n    function lowest_point(point_1, point_2, axis) {\n        /// Returns the lowest point\n        /// <param name=\"axis\" type=\"String\">axis, x or y</param>\n        if (axis == 'x') {\n            if (point_1.x < point_2.x) {\n                return point_1;\n            } else if (point_2.x < point_1.x) {\n                return point_2;\n            } else {\n                console.log(\"points x values are identical\");\n            }\n        } else if (axis == 'y') {\n            if (point_1.y < point_2.y) {\n                return point_1;\n            } else if (point_2.y < point_1.y) {\n                return point_2;\n            } else {\n                return new Point(null, point_1.y);\n            }\n        }\n\n        console.log(\"cannot verify given axis\");\n    }\n\n    function heighest_point(point_1, point_2, axis) {\n        /// Returns the heighest point\n        /// <param name=\"axis\" type=\"String\">axis, x or y</param>\n\n\n        return lowest_point(point_1.negative(), point_2.negative(), axis).negative();\n    }\n\n    return {\n        interpolate_points: interpolate_points,\n        Point: Point,\n        highest_point: heighest_point,\n        lowest_point: lowest_point\n\n    };\n}(); // vector namespace\n'use strict';\n\n// crsn namespace\nvar crsn = function () {\n\n    function PolyGon(point_list) {\n        /// <param name=\"point_list\" type=\"array\">Array with objects from the Point class representing the polygons coordinates</param>\n        this.point_list = point_list;\n        this.n_value = 1000;\n        this.subtractor = null;\n        this.instantiate();\n    }\n\n    PolyGon.prototype.activate_subtractor = function () {\n        this.subtractor.merge_width(this);\n    };\n\n    PolyGon.prototype.instantiate = function () {\n        this.top = this.highest_point('y').y;\n        this.bottom = this.lowest_point('y').y;\n        // all the values on the y-axis\n        this.y_val = this.det_height_array();\n\n        // x_val array has arrays in it representing the results per y_values increment on the y-axis. In these inner arrays are the x-values paired, representing the solid boundaries.\n        this.paired_xvals = [];\n        this.width_array = [];\n        this.return_x_on_axis();\n    };\n\n    PolyGon.prototype.det_height_array = function () {\n        return std.linspace(0, this.top, this.n_value);\n    };\n\n    PolyGon.prototype.lowest_point = function (axis) {\n        /// Find the lowest point on a give axis. \n        /// <param name=\"axis\" type=\"String\">axis, x or y</param>\n\n        var low = this.point_list[0];\n\n        for (var i = 1; i < this.point_list.length; i++) {\n            low = vector.lowest_point(low, this.point_list[i], axis);\n        }\n        return low;\n    };\n\n    PolyGon.prototype.highest_point = function (axis) {\n        var height = this.point_list[0];\n\n        for (var i = 1; i < this.point_list.length; i++) {\n            height = vector.highest_point(height, this.point_list[i], axis);\n        }\n        return height;\n    };\n\n    PolyGon.prototype.return_x_on_axis = function () {\n        /**\r\n        Method for defining the x values of the sections part that hit the polygon sides.\r\n        The y axis is incremented. And with each step the x-axis on this y-value are determined.\r\n        Two x-values means a closed cross section on that y-value. Three or more x-values indicate that\r\n        there is a void in the cross section.\r\n            x1  x2  x3  x4\r\n        _____   _____            y\r\n        |   |   |   |           |\r\n        |   |   |   |           |\r\n        |   |___|   |           |          x\r\n        |___________|           ---------->\r\n           */\n\n        for (var i = 0; i < this.y_val.length; i++) {\n            /** increment a value on the y-axis and search the coordinates of the polygon for crossing edges.\r\n             An edge crosses the x-axis on this y-values height if one coordinate is above and the subsequent/previous\r\n            coordinate is underneath the y-value.\r\n            */\n\n            var y = this.y_val[i] - this.y_val[1] * 0.5;\n\n            // the x_values that intersect the polygon on this y increment.\n            var x_vals = [];\n\n            // iterate through the coordinates\n            for (var a = 0; a < this.point_list.length - 1; a++) {\n                // y-value is between point at index a and point at index a + 1\n                if (this.point_list[a].y >= y == !(this.point_list[a + 1].y >= y)) {\n\n                    var interpolated_point = vector.interpolate_points(this.point_list[a], this.point_list[a + 1], new vector.Point(null, y));\n                    x_vals.push(interpolated_point.x);\n                }\n            }\n            // switch the last index to the front\n            x_vals.sort(function (a, b) {\n                return a - b;\n            });\n            // x_vals contains the x-values. x1 and x2 is solid, x2 and x3 is void, x3 and x4 is solid etc.\n            // Pair the solid x-values like so: [[x1, x2], [x3, x4]]\n\n            var paired_x_vals = [];\n            for (var x = 0; x < x_vals.length; x++) {\n                if ((x + 1) % 2 == 0) {\n                    paired_x_vals.push([x_vals[x - 1], x_vals[x]]);\n                }\n            }\n            this.paired_xvals.push(paired_x_vals);\n\n            // determine the full width on this y-value by summing the dx in the paired lists.\n            var width = 0;\n            for (a = 0; a < paired_x_vals.length; a++) {\n                width += paired_x_vals[a][1] - paired_x_vals[a][0];\n            }\n            this.width_array.push(Math.abs(width));\n        }\n    };\n\n    PolyGon.prototype.area = function () {\n        var dy = this.y_val[1];\n        var area = 0;\n        for (var i = 0; i < this.y_val.length; i++) {\n            area += dy * this.width_array[i];\n        }\n        area = Math.round(area);\n        return Math.abs(area);\n    };\n\n    PolyGon.prototype.zero_line = function () {\n        var dh = (this.top - this.bottom) / this.n_value;\n        var sum_A_h = 0;\n        for (var i in this.width_array) {\n            sum_A_h += dh * this.width_array[i] * this.y_val[i];\n        }\n        return sum_A_h / this.area();\n    };\n\n    // end class\n\n\n    function Circle(radius) {\n        var n = 100;\n        var alpha0 = Math.PI * 2 / n;\n        var pl = [];\n        var p0 = new vector.Point(0, -radius);\n        // translation point. Does nothing else\n        var p_set = new vector.Point(radius, radius);\n        for (var i = 1; i <= n; i++) {\n            var alpha = alpha0 * i;\n\n            var p = p0.rotate_origin(alpha);\n            p = new vector.Point(p.x + p_set.x, p.y + p_set.y);\n\n            pl.push(p);\n        }\n\n        PolyGon.call(this, pl); // call super constructor\n    }\n\n    Circle.prototype = Object.create(PolyGon.prototype);\n    Circle.prototype.constructor = Circle;\n\n    function Subtractor(top, point_list, n_value) {\n        /**\r\n         * @param top (float) Top of the parent cross section (y-value)\r\n         * @param n_value (int) Amount of section in the parent cross section\r\n         */\n        this.point_list = point_list;\n        this.paired_xvals = [];\n        this.width_array = [];\n        this.top = top;\n        this.n_value = n_value;\n        this.y_val = this.det_height_array();\n        this.return_x_on_axis();\n    }\n\n    Subtractor.prototype.merge_width = function (parent) {\n        /**\r\n         * @param parent Object from the parent cross section.\r\n         */\n\n        for (var i in parent.width_array) {\n            parent.width_array[i] -= this.width_array[i];\n\n            // merge the paired x_vals (for the plotter)\n            var x_vals = [];\n            if (this.width_array[i] > 0) {\n\n                //unpack parents paired x_vals\n                for (var j in parent.paired_xvals[i]) {\n                    x_vals.push(parent.paired_xvals[i][j][0]);\n                    x_vals.push(parent.paired_xvals[i][j][1]);\n                }\n                // unpack subtractors paired x_vals\n                for (j in this.paired_xvals[i]) {\n                    x_vals.push(this.paired_xvals[i][j][0]);\n                    x_vals.push(this.paired_xvals[i][j][1]);\n                }\n\n                x_vals.sort(function (a, b) {\n                    return a - b;\n                });\n                // repack them\n                var paired_x_vals = [];\n                for (var x = 0; x < x_vals.length; x++) {\n                    if ((x + 1) % 2 == 0) {\n                        paired_x_vals.push([x_vals[x - 1], x_vals[x]]);\n                    }\n                }\n                parent.paired_xvals[i] = paired_x_vals;\n            }\n        }\n    };\n\n    Subtractor.prototype.return_x_on_axis = PolyGon.prototype.return_x_on_axis;\n    Subtractor.prototype.det_height_array = PolyGon.prototype.det_height_array;\n\n    function Tube(radius_out, radius_in) {\n        var n = 100;\n        var alpha0 = Math.PI * 2 / n;\n        var pl_out = [];\n        var pl_in = [];\n        var p0_out = new vector.Point(0, -radius_out);\n        var p0_in = new vector.Point(0, -radius_in);\n\n        // Translation points. Do nothing else\n        var p_set_in = new vector.Point(radius_out, radius_out);\n        var p_set_out = new vector.Point(radius_out, radius_out);\n\n        for (var i = 1; i <= n + 1; i++) {\n            var alpha = alpha0 * i;\n            var p_out = p0_out.rotate_origin(alpha);\n            p_out = new vector.Point(p_out.x + p_set_out.x, p_out.y + p_set_out.y);\n            var p_in = p0_in.rotate_origin(alpha);\n            p_in = new vector.Point(p_in.x + p_set_in.x, p_in.y + p_set_in.y);\n\n            pl_out.push(p_out);\n            pl_in.push(p_in);\n        }\n        PolyGon.call(this, pl_out);\n\n        this.subtractor = new Subtractor(radius_out * 2, pl_in, this.n_value);\n        this.subtractor.merge_width(this);\n    }\n\n    Tube.prototype = Object.create(PolyGon.prototype);\n    Tube.prototype.constructor = Tube;\n\n    // return from namespace\n    return {\n        PolyGon: PolyGon,\n        Circle: Circle,\n        Tube: Tube,\n        Subtractor: Subtractor\n    };\n}(); // crsn namespace\n'use strict';\nvar DEBUG = false;\n// mkap namespace\nvar mkap = function () {\n\n    //class\n    function MomentKappa(cross_section, compressive_diagram, tensile_diagram) {\n        this.cross_section = cross_section;\n        this.compressive_diagram = compressive_diagram;\n        this.tensile_diagram = tensile_diagram;\n        // sum of the forces in the cross section\n        this.force_tensile = 0;\n        this.force_compression = 0;\n        this.normal_force = 0;\n        this.iterations = 250;\n        this.div = 3;\n\n        /*\r\n        * Reinforcement.\r\n        * For n layers of reinforcement, n parameters need to be initiated in the arrays.\r\n        */\n        this.rebar_As = [];\n        // distance rebar from the bottom of the master cross section\n        this.rebar_z = [];\n        // objects from the StressStrain class\n        this.rebar_diagram = [];\n        // phased rebar\n        this.m0 = [];\n        this.rebar_strain0_plt = [];\n        this.rebar_diam = null; // for the plotter\n\n        // Applied at t=0. 'werkvoorspanning'\n        this.prestress = [];\n\n        // Stress and strain in the reinforcement after Mp has been applied and the deformation is zero.\n        this.d_stress = [];\n        this.d_strain = [];\n        this.mp = 0;\n        // Used by session.js when prestress is applied.\n        this.original_rebar_diagrams = [];\n\n        /**\r\n        results\r\n        */\n        this.solution = null;\n        this.rebar_force = [];\n        this.rebar_strain = [];\n        this.stress = [];\n        this.moment = null;\n        this.kappa = null;\n        this.strain_top = null;\n        this.strain_btm = null;\n        this.zero_line = null; // xu is height - zero line\n        this.xu = null;\n\n        this.reduce_rebar = false;\n    }\n\n    MomentKappa.prototype.det_force_distribution = function (strain_top, strain_btm, reduce_rebar) {\n        /**\r\n         * Sum the tensile and compression forces based on the strain distribution\r\n         *\r\n         * @param strain_top: (float) Strain at the top of the cross section.\r\n         * @param strain_btm: (float) Strain at the bottom of the cross section.\r\n         * @param reduce_rebar: (bool) Subtract the reinforcement cross section of the whole cross section.\r\n         *\r\n         */\n        this.force_compression = 0;\n        this.force_tensile = 0;\n        this.stress = [];\n        this.rebar_strain = [];\n        this.strain_top = strain_top;\n        this.strain_btm = strain_btm;\n\n        // default parameter\n        reduce_rebar = typeof reduce_rebar !== \"undefined\" ? reduce_rebar : false;\n        this.reduce_rebar = reduce_rebar;\n\n        if (this.normal_force < 0) {\n            this.force_tensile += Math.abs(this.normal_force);\n        } else {\n            this.force_compression += Math.abs(this.normal_force);\n        }\n\n        // height of the sections\n        var dh = this.cross_section.y_val[1];\n\n        //cross section\n        var crs_btm = this.cross_section.y_val[0];\n        var crs_top = this.cross_section.y_val[this.cross_section.y_val.length - 1];\n\n        // iterate over the y-axis of the master cross section and determine the stresses.\n        // y-axis starts at bottom.\n        for (var i = 0; i < this.cross_section.y_val.length; i++) {\n\n            // interpolate the strain at this y-value\n            var strain_y = std.interpolate(crs_btm, strain_btm, crs_top, strain_top, this.cross_section.y_val[i]);\n\n            // Send the strain value as parameter in the stress strain diagram\n            if (strain_y < 0) {\n                stress = -this.compressive_diagram.det_stress(Math.abs(strain_y));\n                this.force_compression -= stress * this.cross_section.width_array[i] * dh;\n            } else {\n                stress = this.tensile_diagram.det_stress(strain_y);\n                this.force_tensile += stress * this.cross_section.width_array[i] * dh;\n            }\n            this.stress.push(stress);\n        }\n\n        // determine reinforcement forces\n        this.rebar_force = [];\n        for (i = 0; i < this.rebar_As.length; i++) {\n            var strain = std.interpolate(crs_btm, strain_btm, crs_top, strain_top, this.rebar_z[i]);\n            this.rebar_strain.push(strain + this.d_strain[i]);\n\n            var stress = this.rebar_diagram[i].det_stress(Math.abs(strain));\n\n            // absolute value\n            var force = this.rebar_As[i] * stress;\n\n            var stress_reduct;\n            if (strain < 0 && this.prestress[i] == 0) {\n                this.force_compression += force;\n                this.rebar_force.push(-force);\n\n                if (reduce_rebar) {\n                    // Subtract reinforcement area from master element\n                    stress_reduct = this.compressive_diagram.det_stress(Math.abs(strain));\n                    this.force_compression -= this.rebar_As[i] * stress_reduct;\n                }\n            } else {\n                this.force_tensile += force;\n                this.rebar_force.push(force);\n\n                if (reduce_rebar) {\n                    // Subtract reinforcement area from master element\n                    stress_reduct = this.tensile_diagram.det_stress(strain);\n                    this.force_tensile -= this.rebar_As[i] * stress_reduct;\n                }\n            }\n        }\n    };\n\n    MomentKappa.prototype.set_div = function (str) {\n        /**\r\n         * Up the allowed iterations at small strains. Due to asymptotic behaviour there are more iterations needed.\r\n         *\r\n         * @param str: (float) Strain.\r\n         */\n        if (Math.abs(str) < 0.15) {\n            this.iterations = 500;\n        } else {\n            this.iterations = 250;\n        }\n    };\n\n    MomentKappa.prototype.iterator_top_constant = function (btm_str, top_str) {\n        /**\r\n         * @param btm_str: (float) strain to start\r\n         * @param top_str: (float) strain to start\r\n         */\n\n        // If the reinforcement is above the zero line, there will sometimes be no tensile force\n        // Find the index of the highest reinforcement layer.\n        var top_reinf = Math.min.apply(null, this.rebar_z);\n        for (var i = 0; i < this.rebar_As.length; i++) {\n            if (this.rebar_z[i] == top_reinf) {\n                var rbr_index = i;\n            }\n        }\n\n        var count = 0;\n        // iterate until the convergence criteria is met\n        while (1) {\n            if (std.convergence_conditions(this.force_compression, this.force_tensile)) {\n                this.solution = true;\n                if (false) {\n                    if (false) {\n                        console.log(\"convergence after %s iterations\".replace(\"%s\", count));\n                    }\n                }\n                return [0, count]; // [success, count]\n            }\n\n            // Extrapolate the strain from the first significant rebar strain point, to the bottom strain.\n            // Needed when the rebar is above the neutral line.\n            else if (isNaN(this.force_tensile) || this.force_tensile == 0) {\n                    btm_str = std.interpolate(this.cross_section.top, top_str, top_reinf, this.rebar_diagram[rbr_index].strain[1], this.cross_section.bottom);\n                } else if (this.force_tensile > 0) {\n                    this.set_div(btm_str);\n                    var factor = std.convergence(this.force_tensile, this.force_compression, this.div);\n                    btm_str = btm_str * factor;\n                }\n\n            this.det_force_distribution(top_str, btm_str);\n            if (count > this.iterations) {\n                if (false) {\n                    console.log(\"no convergence found after %s iterations\".replace(\"%s\", count));\n                }\n                return [1, count];\n            }\n            count += 1;\n        }\n    };\n\n    MomentKappa.prototype.iterator_btm_constant = function (btm_str, top_str) {\n        /**\r\n         * @param btm_str: (float) strain to start\r\n         * @param top_str: (float) strain to start\r\n         */\n        var count = 0;\n        // iterate until the convergence criteria is met\n        while (1) {\n            if (std.convergence_conditions(this.force_compression, this.force_tensile)) {\n                this.solution = true;\n\n                if (false) {\n                    console.log(\"convergence after %s iterations\".replace(\"%s\", count));\n                }\n                return [0, count];\n            }\n\n            var factor = std.convergence(this.force_compression, this.force_tensile, this.div);\n            top_str = top_str * factor;\n\n            this.det_force_distribution(top_str, btm_str);\n\n            if (count > this.iterations) {\n                if (false) {\n                    console.log(\"no convergence found after %s iterations\".replace(\"%s\", count));\n                }\n                return [1, count];\n            }\n            count += 1;\n        }\n    };\n\n    MomentKappa.prototype.iterator_complete_pressure = function (top_str) {\n        /**\r\n         * Compression in bottom may not be higher than in top.\r\n         */\n\n        var btm_str = top_str;\n\n        this.det_force_distribution(top_str, btm_str);\n        if (this.force_tensile > this.force_compression) {\n            // No equilibrium possible with positive kappa.\n            return 1;\n        }\n\n        var count = 0;\n        // iterate until the convergence criteria is met\n\n        while (1) {\n            if (std.convergence_conditions(this.force_compression, this.force_tensile)) {\n                this.solution = true;\n\n                if (false) {\n                    console.log(\"convergence after %s iterations\".replace(\"%s\", count));\n                }\n                return [0, count];\n            }\n\n            this.set_div(btm_str);\n\n            var factor = std.convergence(this.force_compression, this.force_tensile, this.div);\n            btm_str = btm_str * factor;\n\n            this.det_force_distribution(top_str, btm_str);\n\n            if (count > this.iterations) {\n\n                if (false) {\n                    console.log(\"no convergence found after %s iterations\".replace(\"%s\", count));\n                }\n                return [1, count];\n            }\n            count += 1;\n        }\n    };\n\n    MomentKappa.prototype.solver = function (strain_top, strain) {\n        /**\r\n         * Return the .det_stress method several times and adapt the input until the convergence criteria is met.\r\n         *\r\n         * @param strain_top: (bool) Constant strain at the top. If true, the strain at the top will remain constant\r\n         *                      and the strain at the bottom will be iterated over. If false vice versa for strain_bottom.\r\n         * @param strain: (float) Constant strain at the top or bottom.\r\n         */\n\n        // default parameter\n        strain_top = typeof strain_top !== \"undefined\" ? strain_top : true;\n\n        this.solution = false;\n        var total_iter = 0;\n\n        // first iteration\n        var btm_str = strain;\n        var top_str = -strain;\n        this.det_force_distribution(top_str, btm_str);\n\n        // If the axial force is substantial start with a solver completely under pressure.\n        var a = this.compressive_diagram.det_stress(-top_str) * this.cross_section.area() * 0.75;\n        if (-this.normal_force > a) {\n            /**\r\n             * Try to solve for a cross section completely under pressure.\r\n             */\n\n            sol = this.iterator_complete_pressure(top_str);\n            if (sol[0] === 0) {\n                return sol[1];\n            } else {\n                total_iter += sol[1];\n\n                if (strain_top) {\n                    // top strain remains constant\n                    var sol = this.iterator_top_constant(btm_str, top_str);\n                    if (sol[0] === 0) {\n                        return sol[1];\n                    } else {\n                        total_iter += sol[1];\n                    }\n                } else {\n                    // bottom strain remains constant\n                    sol = this.iterator_btm_constant(btm_str, top_str);\n                    if (sol[0] === 0) {\n                        return sol[1];\n                    } else {\n                        total_iter += sol[1];\n                    }\n                }\n            }\n        }\n        // Standard control flow\n        else {\n\n                if (strain_top) {\n                    // top strain remains constant\n                    var sol = this.iterator_top_constant(btm_str, top_str);\n                    if (sol[0] === 0) {\n                        return sol[1];\n                    } else {\n                        total_iter += sol[1];\n                    }\n                } else {\n                    // bottom strain remains constant\n                    sol = this.iterator_btm_constant(btm_str, top_str);\n                    if (sol[0] === 0) {\n                        return sol[1];\n                    } else {\n                        total_iter += sol[1];\n                    }\n                }\n\n                if (!this.validity() && this.normal_force != 0) {\n                    /**\r\n                     * Try to solve for a cross section completely under pressure.\r\n                     */\n\n                    sol = this.iterator_complete_pressure(top_str);\n                    if (sol[0] === 0) {\n                        return sol[1];\n                    } else {\n                        total_iter += sol[1];\n                    }\n                }\n            }\n        return total_iter;\n    };\n\n    MomentKappa.prototype.det_m_kappa = function () {\n        /**\r\n        Determines the moment and kappa values.\r\n              For each sections center of gravity the moment around the origin is determined.\r\n          \r\n        ______     <---- - F compression \r\n        |     |         \r\n        |     |                           |y\r\n        |     |                           |\r\n        |_____|    ----> + F tensile      |0____x\r\n        \r\n        */\n\n        // center of gravity offset of a section\n        this.kappa = (-this.strain_top + this.strain_btm) / (this.cross_section.top - this.cross_section.bottom);\n        this.moment = this.mp;\n        var offset = this.cross_section.y_val[1] * 0.5;\n\n        // height of the sections\n        var dh = this.cross_section.y_val[1];\n\n        for (var i = 0; i < this.cross_section.y_val.length; i++) {\n            var arm = this.cross_section.y_val[i] + offset;\n            var force = this.stress[i] * this.cross_section.width_array[i] * dh;\n\n            this.moment += arm * force;\n        }\n\n        // N normal force share\n        this.moment -= this.normal_force * this.cross_section.zero_line();\n\n        // rebar share\n        for (i = 0; i < this.rebar_As.length; i++) {\n            this.moment += this.rebar_force[i] * this.rebar_z[i];\n\n            // reduction of master cross section at place of rebar\n            if (this.reduce_rebar) {\n                if (this.rebar_force[i] > 0) {\n                    // tensile stress\n                    var stress_reduct = this.tensile_diagram.det_stress(this.rebar_strain[i]);\n                    //this.moment -= stress_reduct * this.rebar_As[i] * this.rebar_z[i]\n                } else {\n                    // compression stress\n                    stress_reduct = -this.compressive_diagram.det_stress(Math.abs(this.rebar_strain[i]));\n                    //this.moment -= stress_reduct * this.rebar_As[i] * this.rebar_z[i]\n                }\n            }\n        }\n\n        this.moment *= -1;\n        // zero line\n        this.zero_line = std.interpolate(this.strain_btm, this.cross_section.bottom, this.strain_top, this.cross_section.top, 0);\n        this.xu = this.cross_section.top - this.zero_line;\n    };\n\n    MomentKappa.prototype.validity = function () {\n        /**\r\n         * Check if the found equilibrium solution could be regarded as valid.\r\n         *\r\n         * @type {boolean}\r\n         */\n        var valid = true;\n        if (std.is_number(this.moment) && std.is_number(this.kappa) && this.solution && this.strain_top >= -this.compressive_diagram.strain[this.compressive_diagram.strain.length - 1] && this.strain_top < 0) {\n            for (var i in this.rebar_strain) {\n                if (Math.abs(this.rebar_strain[i]) > Math.max.apply(null, this.rebar_diagram[i].strain)) {\n                    valid = false;\n                }\n            }\n\n            if (std.is_close(this.strain_btm, 0, 0.01, 0.01)) {\n                if (this.xu >= this.cross_section.top - this.cross_section.bottom) {\n                    return false;\n                }\n            }\n        } else {\n            valid = false;\n        }\n        return valid;\n    };\n\n    MomentKappa.prototype.instantiate_standard_reinforcement = function (As, rebar_z, rebar_diagram) {\n        /**\r\n         * Instantiate standard moment kappa solver. Because of the extra options regarding phased moments, prestress\r\n         * etc. some extra parameters need to be instantiated.\r\n         *\r\n         * @param As: {Array} Area of the reinforcement per layer.\r\n         * @param rebar_z: {Array} Height of the reinforcement layer with respect to the bottom of the cross section.\r\n         * @param rebar_diagram: {StressStrain} Diagram object.\r\n         */\n\n        this.rebar_z = rebar_z;\n        this.rebar_As = As;\n\n        this.prestress = this.m0 = this.d_stress = this.d_strain = Array.apply(null, Array(As.length)).map(Number.prototype.valueOf, 0);\n\n        this.rebar_diagram = Array.apply(null, Array(As.length)).map(function () {\n            return rebar_diagram;\n        });\n    };\n\n    function StressStrain(strain, stress) {\n        /**\r\n         * Class for creating stress strain diagrams.\r\n         *\r\n         * @param strain: (array) Strain values of the diagram.\r\n         * @param stress: (array) Stress values of the diagram.\r\n        */\n\n        this.strain = strain;\n        this.stress = stress;\n    }\n\n    StressStrain.prototype.det_stress = function (strain) {\n        /**\r\n         * @param strain: (float) Strain for which the stress needs to be determined.\r\n         * Iterate through the strain array until iterated value exceeds the requested strain.\r\n         * At that the point the two values will interpolated.\r\n         */\n\n        for (var i = 0; i < this.strain.length; i++) {\n            if (strain > this.strain[this.strain.length - 1]) {\n                return 0;\n            } else if (this.strain[i] == strain) {\n                return this.stress[i];\n            } else if (this.strain[i] > strain) {\n                return std.interpolate(this.strain[i - 1], this.stress[i - 1], this.strain[i], this.stress[i], strain);\n            }\n        }\n    };\n\n    StressStrain.prototype.det_strain = function (stress) {\n        /**\r\n         * @param stress: (float) Strain for which the stress needs to be determined.\r\n         * Iterate through the stress array until iterated value exceeds the requested strain.\r\n         * At that the point the two values will interpolated.\r\n         */\n        for (var i = 0; i < this.stress.length; i++) {\n            if (stress > this.stress[this.stress.length - 1]) {\n                return 0;\n            } else if (this.stress[i] == stress) {\n                return this.strain[i];\n            } else if (this.stress[i] > stress) {\n                return std.interpolate(this.stress[i - 1], this.strain[i - 1], this.stress[i], this.strain[i], stress);\n            }\n        }\n    };\n\n    function calcHookup(reduction, mkap, top) {\n        /**\r\n         * Reduction factor (float)\r\n         *\r\n         * Starts the calculation with the latest point of the compression material and reduces it until a solution is found.\r\n         * Returns the strain that resulted in a valid solution.\r\n         *\r\n         * @param reduction: {float} the reduction factor of the strain.\r\n         * @param mkap: {object} from the MomentKappa class.\r\n         * @param top: {bool} Depends if the hookup is sought for the top or the bottom of the cross section.\r\n         */\n        top = typeof top !== \"undefined\" ? top : true;\n        var strain;\n        if (top) {\n            strain = mkap.compressive_diagram.strain[mkap.compressive_diagram.strain.length - 1];\n        } else {\n            strain = mkap.tensile_diagram.strain[mkap.tensile_diagram.strain.length - 1];\n        }\n\n        mkap.solver(top, strain);\n        mkap.det_m_kappa();\n\n        var count = 0;\n        while (!mkap.validity() && count < 150) {\n            mkap.solver(top, strain);\n            mkap.det_m_kappa();\n            strain *= 1 - reduction;\n            count += 1;\n        }\n        return strain;\n    }\n\n    return { MomentKappa: MomentKappa,\n        StressStrain: StressStrain,\n        calcHookup: calcHookup\n    };\n}(); // mkap namespace\n\n\nmodule.exports = {\n    std: std,\n    mkap: mkap,\n    vector: vector,\n    crsn: crsn\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvdmFuaWxsYV9ta2FwLm1pbi5qcz82ZTUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHN0ZCBuYW1lc3BhY2VcclxudmFyIHN0ZCA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gaXNfY2xvc2UoYSwgYiwgcmVsX3RvbCwgYWJzX3RvbCkge1xyXG5cclxuICAgICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKGEgLSBiKTtcclxuICAgICAgICBpZiAoZGlmZiA8PSBhYnNfdG9sKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChNYXRoLmFicyhhKSA8IE1hdGguYWJzKGIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkaWZmIDw9IE1hdGguYWJzKGIpICogcmVsX3RvbFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRpZmYgPD0gTWF0aC5hYnMoYSkgKiByZWxfdG9sXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBpc19udW1iZXIob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG9iaikpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGUoc3RhcnRfeCwgc3RhcnRfeSwgZW5kX3gsIGVuZF95LCByZXFfeCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgIERldGVybWluYXRlcyB0aGUgeS12YWx1ZSBieSBpbnRlcnBvbGF0aW9uIGZvciB0aGUgZ2l2ZW4geC0gYW5kIHktdmFsdWVzLlxyXG4gICAgICAgIERvZXMgYWxzbyBleHRyYXBvbGF0ZVxyXG4gICAgICAgICovXHJcblxyXG4gICAgICAgIC8vIERpZmZlcmVuY3RlIGJldHdlZW4gZW5kIHBvaW50IGFuZCBzdGFydCBwb2ludFxyXG4gICAgICAgIHZhciBkeCA9IGVuZF94IC0gc3RhcnRfeDtcclxuICAgICAgICB2YXIgZHkgPSBlbmRfeSAtIHN0YXJ0X3k7XHJcblxyXG4gICAgICAgIC8vIGRpZmZlcmVuY2UgYmV0d2VlbiByZXF1ZXN0ZWQgcG9pbnRzIHZhbHVlIGFuZCBzdGFydCBwb2ludHMgdmFsdWVcclxuICAgICAgICB2YXIgZGVsdGFfeCA9IHJlcV94IC0gc3RhcnRfeDtcclxuICAgICAgICB2YXIgZmFjdG9yID0gZGVsdGFfeCAvIGR4O1xyXG4gICAgICAgIHZhciBkZWx0YV95ID0gZmFjdG9yICogZHk7XHJcblxyXG4gICAgICAgIHJldHVybiBzdGFydF95ICsgZGVsdGFfeVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbnZlcmdlbmNlKGxocywgcmhzLCBkaXYpIHtcclxuICAgICAgICAvKipDb252ZXJ0aW5nIGJ5IGFkYXB0aW5nIG9uZSB2YWx1ZSBieSBhIGZhY3Rvci4gVGhlIGZhY3RvciBpcyBkZXRlcm1pbmVkIGJ5IHRoZSByYXRpbyBvZiB0aGUgbGVmdCBoYW5kIHNpZGUgYW5kXHJcbiAgICAgICAgICogdGhlIHJpZ2h0IGhhbmQgc2lkZSBvZiB0aGUgZXF1YXRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBGYWN0b3I6ICgoTGVmdCAvIFJpZ2h0KSAtIDEpIC8gZGl2ICsgMVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHJoczoge2Zsb2F0fSBWYWx1ZVxyXG4gICAgICAgICAqIEBwYXJhbSBsaHM6IHtmbG9hdH0gVmFsdWVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIENvbnZlcmdlbmNlID0gbGhzICo9IGZhY3RvclxyXG4gICAgICAgICovXHJcbiAgICAgICAgLy8gZGVmYXVsdCBwYXJhbWV0ZXJcclxuICAgICAgICBkaXYgPSAodHlwZW9mIGRpdiAhPT0gXCJ1bmRlZmluZWRcIikgPyBkaXY6IDM7XHJcblxyXG4gICAgICAgIHZhciByYXRpbyA9IE1hdGguYWJzKHJocykgLyBNYXRoLmFicyhsaHMpO1xyXG4gICAgICAgIHJldHVybiAocmF0aW8gLSAxKSAvIGRpdiArIDFcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb252ZXJnZW5jZV9jb25kaXRpb25zKGxocywgcmhzLCBsaW1pdF91cCwgbGltaXRfbG93ZXIpIHtcclxuICAgICAgICAvLyBkZWZhdWx0IHBhcmFtZXRlclxyXG4gICAgICAgIGxpbWl0X3VwID0gKHR5cGVvZiBsaW1pdF91cCAhPT0gXCJ1bmRlZmluZWRcIikgPyBsaW1pdF91cCA6IDEuMDAxO1xyXG4gICAgICAgIGxpbWl0X2xvd2VyID0gKHR5cGVvZiBsaW1pdF9sb3dlciAhPT0gXCJ1bmRlZmluZWRcIikgPyBsaW1pdF9sb3dlciA6IDAuOTk5O1xyXG5cclxuICAgICAgICB2YXIgcmF0aW8gPSBNYXRoLmFicyhyaHMpIC8gTWF0aC5hYnMobGhzKTtcclxuICAgICAgICByZXR1cm4gKGxpbWl0X2xvd2VyIDw9IHJhdGlvICYmIHJhdGlvIDw9IGxpbWl0X3VwKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG5lYXJlc3RfaW5kZXgoYXJyLCB4KSB7XHJcbiAgICAgICAgLyogXHJcbiAgICAgICAgUmV0dXJuIHRoZSBuZWFyZXN0IGluZGV4ZXMgb2YgYW4gYXJyYXkuXHJcbiAgICAgICAgKi9cclxuICAgICAgICB2YXIgbG93ZXIgPSBbXTtcclxuICAgICAgICB2YXIgaGlnaGVyID0gW107XHJcblxyXG4gICAgICAgIGFyci5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgICAgKCh2YWwgPCB4KSAmJiBsb3dlci5wdXNoKHZhbCkgfHwgKHZhbCA+IHgpICYmIGhpZ2hlci5wdXNoKHZhbCkpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcImxvd1wiOiBhcnIuaW5kZXhPZihNYXRoLm1heC5hcHBseShudWxsLCBsb3dlcikpLCBcImhpZ2hcIjogYXJyLmluZGV4T2YoTWF0aC5taW4uYXBwbHkobnVsbCwgaGlnaGVyKSl9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbGluc3BhY2UgKGEsIGIsIG4pIHtcclxuICAgICAgICBpZiAodHlwZW9mIG4gPT09ICd1bmRlZmluZWQnKSBuID0gTWF0aC5tYXgoTWF0aC5yb3VuZChiIC0gYSkgKyAxLCAxKTtcclxuICAgICAgICBpZiAobiA8IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG4gPT09IDEgPyBbYV0gOiBbXVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaSwgcmV0ID0gQXJyYXkobik7XHJcbiAgICAgICAgbi0tO1xyXG4gICAgICAgIGZvciAoaSA9IG47IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHJldFtpXSA9IChpICogYiArIChuIC0gaSkgKiBhKSAvIG5cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldFxyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cclxuICAgIC8vIHJldHVybiBmcm9tIG5hbWVzcGFjZVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpbnRlcnBvbGF0ZTogaW50ZXJwb2xhdGUsXHJcbiAgICAgICAgY29udmVyZ2VuY2U6IGNvbnZlcmdlbmNlLFxyXG4gICAgICAgIGNvbnZlcmdlbmNlX2NvbmRpdGlvbnM6IGNvbnZlcmdlbmNlX2NvbmRpdGlvbnMsXHJcbiAgICAgICAgaXNfbnVtYmVyOiBpc19udW1iZXIsXHJcbiAgICAgICAgbmVhcmVzdF9pbmRleDogbmVhcmVzdF9pbmRleCxcclxuICAgICAgICBpc19jbG9zZTogaXNfY2xvc2UsXHJcbiAgICAgICAgbGluc3BhY2U6IGxpbnNwYWNlXHJcbiAgICB9XHJcbiAgICBcclxufSkoKTsgIC8vIHN0ZCBuYW1lc3BhY2VcclxuXHJcblxyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gdmVjdG9yIG5hbWVzcGFjZVxyXG52YXIgdmVjdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgREVCVUcgPSBmYWxzZTtcclxuXHJcbi8vY2xhc3NcclxuZnVuY3Rpb24gUG9pbnQoeCwgeSkge1xyXG4gICAgdGhpcy54ID0geDtcclxuICAgIHRoaXMueSA9IHlcclxufVxyXG5cclxuUG9pbnQucHJvdG90eXBlLm1vZHVsdXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMueCwgMikgKyBNYXRoLnBvdyh0aGlzLnksIDIpKVxyXG59O1xyXG5cclxuUG9pbnQucHJvdG90eXBlLm5lZ2F0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG5ldyBQb2ludCgtdGhpcy54LCAtdGhpcy55KTtcclxufTtcclxuXHJcblBvaW50LnByb3RvdHlwZS5yb3RhdGVfb3JpZ2luID0gZnVuY3Rpb24gKGFscGhhKSB7XHJcbiAgICB2YXIgcmFkaXVzID0gdGhpcy5tb2R1bHVzKCk7XHJcbiAgICB2YXIgYWxwaGEwID0gdGhpcy5hbmdsZV9vcmdpbl94X2F4aXMoKTtcclxuICAgIHZhciBuZXdfcCA9IG5ldyBQb2ludCgwLCAwKTtcclxuICAgIG5ld19wLmRpc3BsYWNlX3BvbGFyKGFscGhhICsgYWxwaGEwLCByYWRpdXMpO1xyXG4gICAgcmV0dXJuIG5ld19wXHJcbn07XHJcblxyXG5Qb2ludC5wcm90b3R5cGUuZGlzcGxhY2VfcG9sYXIgPSBmdW5jdGlvbiAoYWxwaGEsIHJhZGl1cykge1xyXG4gICAgdGhpcy54ICs9IE1hdGguY29zKGFscGhhKSAqIHJhZGl1cztcclxuICAgIHRoaXMueSArPSBNYXRoLnNpbihhbHBoYSkgKiByYWRpdXNcclxufTtcclxuXHJcblBvaW50LnByb3RvdHlwZS5hbmdsZV9vcmdpbl94X2F4aXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgIERldGVybWluZSB0aGUgYW5nbGUgYmV0d2VlbiB0aGUgb3JpZ2luICh4LWF4aXM9MCwgei1heGlzPTApIGFuZCB0aGUgcG9pbnQuXHJcbiAgICAqL1xyXG5cclxuICAgIGlmICh0aGlzLnkgPT0gMCkgeyAgIC8vIGhvcml6b250YWxcclxuICAgICAgICBpZiAodGhpcy54ID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgYWxwaGEgPSAwXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhbHBoYSA9IE1hdGguUEk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGhpcy54ID09IDApIHsgLy8gdmVydGljYWxcclxuICAgICAgICBpZiAodGhpcy55ID4gMCkge1xyXG4gICAgICAgICAgICBhbHBoYSA9IDAuNSAqIE1hdGguUElcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFscGhhID0gMS41ICogTWF0aC5QSVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRoaXMueCA+IDAgJiYgdGhpcy55ID4gMCkgeyAgLy8gcXVhZHJhbnQgMVxyXG4gICAgICAgIGFscGhhID0gTWF0aC5hdGFuKE1hdGguYWJzKHRoaXMueSAvIHRoaXMueCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGhpcy54IDwgMCAmJiAwIDwgdGhpcy55KSB7IC8vIHF1YWRyYW50IDJcclxuICAgICAgICBhbHBoYSA9IDAuNSAqIE1hdGguUEkgKyBNYXRoLmF0YW4oTWF0aC5hYnModGhpcy54IC8gdGhpcy55KSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0aGlzLnggPCAwICYmIHRoaXMueSA8IDApIHsgLy8gcXVhZHJhbnQgM1xyXG4gICAgICAgIGFscGhhID0gTWF0aC5QSSArIE1hdGguYXRhbihNYXRoLmFicyh0aGlzLnkgLyB0aGlzLngpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRoaXMueCA+IDAgJiYgMCA+IHRoaXMueSkgeyAvLyBxdWFkcmFudCA0XHJcbiAgICAgICAgYWxwaGEgPSAxLjUgKiBNYXRoLlBJICsgTWF0aC5hdGFuKE1hdGguYWJzKHRoaXMueCAvIHRoaXMueSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKERFQlVHKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ2FuIG5vdCBkZXRlcm1pbmUgdGhlIGFuZ2xlIG9mIHRoZSBwb2ludCB3aXRoIHRoZSBheGVzIG9yaWdpblwiKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYWxwaGFcclxufTtcclxuXHJcblxyXG5cclxuXHJcblxyXG4vL2VuZCBjbGFzc1xyXG5cclxuXHJcbmZ1bmN0aW9uIGludGVycG9sYXRlX3BvaW50cyhzdGFydF9wLCBlbmRfcCwgcmVxX3ApIHtcclxuICAgIC8vLyA8cGFyYW0gbmFtZT1cInN0YXJ0X3BcIiB0eXBlPVwiT2JqZWN0IGZyb20gUG9pbnQgY2xhc3NcIj5yZWZlcmVuY2UgdmFsdWUgdGhhdCBzaG91bGQgYmUgaW50ZXJwb2xhdGVkIGJldHdlZW48L3BhcmFtPlxyXG4gICAgLy8vIDxwYXJhbSBuYW1lPVwiZW5kX3BcIiB0eXBlPVwiT2JqZWN0IGZyb20gUG9pbnQgY2xhc3NcIj5yZWZlcmVuY2UgdmFsdWUgdGhhdCBzaG91bGQgYmUgaW50ZXJwb2xhdGVkIGJldHdlZW48L3BhcmFtPlxyXG4gICAgLy8vIDxwYXJhbSBuYW1lPVwicmVxX3BcIiB0eXBlPVwiT2JqZWN0IGZyb20gUG9pbnQgY2xhc3NcIj5WYWx1ZSB0aGF0IGlzIHJlcXVlc3RlZC4geCBvciB5IG9mIHRoZSBvYmplY3Qgc2hvdWxkIGJlIG51bGwsIG9uIHRoZSByZXF1ZXN0IHRpbWUuPC9wYXJhbT5cclxuXHJcbiAgICAvLyBEaWZmZXJlbmN0ZSBiZXR3ZWVuIGVuZCBwb2ludCBhbmQgc3RhcnQgcG9pbnRcclxuICAgIHZhciBkX3ggPSBlbmRfcC54IC0gc3RhcnRfcC54O1xyXG4gICAgdmFyIGRfeSA9IGVuZF9wLnkgLSBzdGFydF9wLnk7XHJcblxyXG4gICAgaWYgKHJlcV9wLnkgPT0gbnVsbCkge1xyXG4gICAgICAgIC8vIGRpZmZlcmVuY2UgYmV0d2VlbiByZXF1ZXN0ZWQgcG9pbnRzIHZhbHVlIGFuZCBzdGFydCBwb2ludHMgdmFsdWVcclxuICAgICAgICB2YXIgZGVsdGFfeCA9IHJlcV9wLnggLSBzdGFydF9wLng7XHJcblxyXG4gICAgICAgIHZhciBmYWN0b3IgPSBkZWx0YV94IC8gZF94O1xyXG4gICAgICAgIHZhciBkZWx0YV95ID0gZF95ICogZmFjdG9yO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmVxX3AueCA9PSBudWxsKSB7XHJcbiAgICAgICAgZGVsdGFfeSA9IHJlcV9wLnkgLSBzdGFydF9wLnk7XHJcblxyXG4gICAgICAgIGZhY3RvciA9IGRlbHRhX3kgLyBkX3k7XHJcbiAgICAgICAgZGVsdGFfeCA9IGRfeCAqIGZhY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFBvaW50KHN0YXJ0X3AueCArIGRlbHRhX3gsIHN0YXJ0X3AueSArIGRlbHRhX3kpO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gbG93ZXN0X3BvaW50KHBvaW50XzEsIHBvaW50XzIsIGF4aXMpIHtcclxuICAgIC8vLyBSZXR1cm5zIHRoZSBsb3dlc3QgcG9pbnRcclxuICAgIC8vLyA8cGFyYW0gbmFtZT1cImF4aXNcIiB0eXBlPVwiU3RyaW5nXCI+YXhpcywgeCBvciB5PC9wYXJhbT5cclxuICAgIGlmIChheGlzID09ICd4Jykge1xyXG4gICAgICAgIGlmIChwb2ludF8xLnggPCBwb2ludF8yLngpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBvaW50XzE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBvaW50XzIueCA8IHBvaW50XzEueCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcG9pbnRfMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicG9pbnRzIHggdmFsdWVzIGFyZSBpZGVudGljYWxcIilcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChheGlzID09ICd5Jykge1xyXG4gICAgICAgIGlmIChwb2ludF8xLnkgPCBwb2ludF8yLnkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBvaW50XzE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBvaW50XzIueSA8IHBvaW50XzEueSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcG9pbnRfMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQobnVsbCwgcG9pbnRfMS55KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhcImNhbm5vdCB2ZXJpZnkgZ2l2ZW4gYXhpc1wiKVxyXG59XHJcblxyXG5mdW5jdGlvbiBoZWlnaGVzdF9wb2ludChwb2ludF8xLCBwb2ludF8yLCBheGlzKSB7XHJcbiAgICAvLy8gUmV0dXJucyB0aGUgaGVpZ2hlc3QgcG9pbnRcclxuICAgIC8vLyA8cGFyYW0gbmFtZT1cImF4aXNcIiB0eXBlPVwiU3RyaW5nXCI+YXhpcywgeCBvciB5PC9wYXJhbT5cclxuXHJcblxyXG4gICAgcmV0dXJuIGxvd2VzdF9wb2ludChwb2ludF8xLm5lZ2F0aXZlKCksIHBvaW50XzIubmVnYXRpdmUoKSwgYXhpcykubmVnYXRpdmUoKVxyXG59XHJcblxyXG5yZXR1cm4ge1xyXG4gICAgaW50ZXJwb2xhdGVfcG9pbnRzOiBpbnRlcnBvbGF0ZV9wb2ludHMsXHJcbiAgICBQb2ludDogUG9pbnQsXHJcbiAgICBoaWdoZXN0X3BvaW50OiBoZWlnaGVzdF9wb2ludCxcclxuICAgIGxvd2VzdF9wb2ludDogbG93ZXN0X3BvaW50XHJcblxyXG5cclxufVxyXG5cclxufSkoKTsgIC8vIHZlY3RvciBuYW1lc3BhY2VcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gY3JzbiBuYW1lc3BhY2VcclxudmFyIGNyc24gPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuZnVuY3Rpb24gUG9seUdvbihwb2ludF9saXN0KSB7XHJcbiAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludF9saXN0XCIgdHlwZT1cImFycmF5XCI+QXJyYXkgd2l0aCBvYmplY3RzIGZyb20gdGhlIFBvaW50IGNsYXNzIHJlcHJlc2VudGluZyB0aGUgcG9seWdvbnMgY29vcmRpbmF0ZXM8L3BhcmFtPlxyXG4gICAgdGhpcy5wb2ludF9saXN0ID0gcG9pbnRfbGlzdDtcclxuICAgIHRoaXMubl92YWx1ZSA9IDEwMDA7XHJcbiAgICB0aGlzLnN1YnRyYWN0b3IgPSBudWxsO1xyXG4gICAgdGhpcy5pbnN0YW50aWF0ZSgpXHJcbn1cclxuXHJcblBvbHlHb24ucHJvdG90eXBlLmFjdGl2YXRlX3N1YnRyYWN0b3IgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLnN1YnRyYWN0b3IubWVyZ2Vfd2lkdGgodGhpcylcclxuICAgIH07XHJcblxyXG5Qb2x5R29uLnByb3RvdHlwZS5pbnN0YW50aWF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMudG9wID0gdGhpcy5oaWdoZXN0X3BvaW50KCd5JykueTtcclxuICAgIHRoaXMuYm90dG9tID0gdGhpcy5sb3dlc3RfcG9pbnQoJ3knKS55O1xyXG4gICAgLy8gYWxsIHRoZSB2YWx1ZXMgb24gdGhlIHktYXhpc1xyXG4gICAgdGhpcy55X3ZhbCA9IHRoaXMuZGV0X2hlaWdodF9hcnJheSgpO1xyXG5cclxuICAgIC8vIHhfdmFsIGFycmF5IGhhcyBhcnJheXMgaW4gaXQgcmVwcmVzZW50aW5nIHRoZSByZXN1bHRzIHBlciB5X3ZhbHVlcyBpbmNyZW1lbnQgb24gdGhlIHktYXhpcy4gSW4gdGhlc2UgaW5uZXIgYXJyYXlzIGFyZSB0aGUgeC12YWx1ZXMgcGFpcmVkLCByZXByZXNlbnRpbmcgdGhlIHNvbGlkIGJvdW5kYXJpZXMuXHJcbiAgICB0aGlzLnBhaXJlZF94dmFscyA9IFtdO1xyXG4gICAgdGhpcy53aWR0aF9hcnJheSA9IFtdO1xyXG4gICAgdGhpcy5yZXR1cm5feF9vbl9heGlzKCk7XHJcbiAgICB9O1xyXG5cclxuUG9seUdvbi5wcm90b3R5cGUuZGV0X2hlaWdodF9hcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBzdGQubGluc3BhY2UoMCwgdGhpcy50b3AsIHRoaXMubl92YWx1ZSlcclxufTtcclxuXHJcblBvbHlHb24ucHJvdG90eXBlLmxvd2VzdF9wb2ludCA9IGZ1bmN0aW9uIChheGlzKSB7XHJcbiAgICAvLy8gRmluZCB0aGUgbG93ZXN0IHBvaW50IG9uIGEgZ2l2ZSBheGlzLiBcclxuICAgIC8vLyA8cGFyYW0gbmFtZT1cImF4aXNcIiB0eXBlPVwiU3RyaW5nXCI+YXhpcywgeCBvciB5PC9wYXJhbT5cclxuXHJcbiAgICB2YXIgbG93ID0gdGhpcy5wb2ludF9saXN0WzBdO1xyXG4gICAgXHJcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMucG9pbnRfbGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxvdyA9IHZlY3Rvci5sb3dlc3RfcG9pbnQobG93LCB0aGlzLnBvaW50X2xpc3RbaV0sIGF4aXMpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG93XHJcbn07XHJcblxyXG5Qb2x5R29uLnByb3RvdHlwZS5oaWdoZXN0X3BvaW50ID0gZnVuY3Rpb24gKGF4aXMpIHtcclxuICAgIHZhciBoZWlnaHQgPSB0aGlzLnBvaW50X2xpc3RbMF07XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLnBvaW50X2xpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBoZWlnaHQgPSB2ZWN0b3IuaGlnaGVzdF9wb2ludChoZWlnaHQsIHRoaXMucG9pbnRfbGlzdFtpXSwgYXhpcylcclxuICAgIH1cclxuICAgIHJldHVybiBoZWlnaHRcclxufTtcclxuXHJcblxyXG5Qb2x5R29uLnByb3RvdHlwZS5yZXR1cm5feF9vbl9heGlzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICBNZXRob2QgZm9yIGRlZmluaW5nIHRoZSB4IHZhbHVlcyBvZiB0aGUgc2VjdGlvbnMgcGFydCB0aGF0IGhpdCB0aGUgcG9seWdvbiBzaWRlcy5cclxuICAgIFRoZSB5IGF4aXMgaXMgaW5jcmVtZW50ZWQuIEFuZCB3aXRoIGVhY2ggc3RlcCB0aGUgeC1heGlzIG9uIHRoaXMgeS12YWx1ZSBhcmUgZGV0ZXJtaW5lZC5cclxuICAgIFR3byB4LXZhbHVlcyBtZWFucyBhIGNsb3NlZCBjcm9zcyBzZWN0aW9uIG9uIHRoYXQgeS12YWx1ZS4gVGhyZWUgb3IgbW9yZSB4LXZhbHVlcyBpbmRpY2F0ZSB0aGF0XHJcbiAgICB0aGVyZSBpcyBhIHZvaWQgaW4gdGhlIGNyb3NzIHNlY3Rpb24uXHJcblxyXG5cclxuICAgIHgxICB4MiAgeDMgIHg0XHJcbiAgICBfX19fXyAgIF9fX19fICAgICAgICAgICAgeVxyXG4gICAgfCAgIHwgICB8ICAgfCAgICAgICAgICAgfFxyXG4gICAgfCAgIHwgICB8ICAgfCAgICAgICAgICAgfFxyXG4gICAgfCAgIHxfX198ICAgfCAgICAgICAgICAgfCAgICAgICAgICB4XHJcbiAgICB8X19fX19fX19fX198ICAgICAgICAgICAtLS0tLS0tLS0tPlxyXG5cclxuICAgICAqL1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy55X3ZhbC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIC8qKiBpbmNyZW1lbnQgYSB2YWx1ZSBvbiB0aGUgeS1heGlzIGFuZCBzZWFyY2ggdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2x5Z29uIGZvciBjcm9zc2luZyBlZGdlcy5cclxuICAgICAgICAgQW4gZWRnZSBjcm9zc2VzIHRoZSB4LWF4aXMgb24gdGhpcyB5LXZhbHVlcyBoZWlnaHQgaWYgb25lIGNvb3JkaW5hdGUgaXMgYWJvdmUgYW5kIHRoZSBzdWJzZXF1ZW50L3ByZXZpb3VzXHJcbiAgICAgICAgY29vcmRpbmF0ZSBpcyB1bmRlcm5lYXRoIHRoZSB5LXZhbHVlLlxyXG4gICAgICAgICovXHJcblxyXG4gICAgICAgIHZhciB5ID0gdGhpcy55X3ZhbFtpXSAtIHRoaXMueV92YWxbMV0gKiAwLjU7XHJcblxyXG4gICAgICAgIC8vIHRoZSB4X3ZhbHVlcyB0aGF0IGludGVyc2VjdCB0aGUgcG9seWdvbiBvbiB0aGlzIHkgaW5jcmVtZW50LlxyXG4gICAgICAgIHZhciB4X3ZhbHMgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gaXRlcmF0ZSB0aHJvdWdoIHRoZSBjb29yZGluYXRlc1xyXG4gICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgdGhpcy5wb2ludF9saXN0Lmxlbmd0aCAtIDE7IGErKykge1xyXG4gICAgICAgICAgICAvLyB5LXZhbHVlIGlzIGJldHdlZW4gcG9pbnQgYXQgaW5kZXggYSBhbmQgcG9pbnQgYXQgaW5kZXggYSArIDFcclxuICAgICAgICAgICAgaWYgKCh0aGlzLnBvaW50X2xpc3RbYV0ueSA+PSB5KSA9PSAhKHRoaXMucG9pbnRfbGlzdFthICsgMV0ueSA+PSB5KSkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBpbnRlcnBvbGF0ZWRfcG9pbnQgPSB2ZWN0b3IuaW50ZXJwb2xhdGVfcG9pbnRzKHRoaXMucG9pbnRfbGlzdFthXSwgdGhpcy5wb2ludF9saXN0W2EgKyAxXSxcclxuICAgICAgICAgICAgICAgICAgICBuZXcgdmVjdG9yLlBvaW50KG51bGwsIHkpKTtcclxuICAgICAgICAgICAgICAgIHhfdmFscy5wdXNoKGludGVycG9sYXRlZF9wb2ludC54KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzd2l0Y2ggdGhlIGxhc3QgaW5kZXggdG8gdGhlIGZyb250XHJcbiAgICAgICAgeF92YWxzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgLSBiIH0pO1xyXG4gICAgICAgIC8vIHhfdmFscyBjb250YWlucyB0aGUgeC12YWx1ZXMuIHgxIGFuZCB4MiBpcyBzb2xpZCwgeDIgYW5kIHgzIGlzIHZvaWQsIHgzIGFuZCB4NCBpcyBzb2xpZCBldGMuXHJcbiAgICAgICAgLy8gUGFpciB0aGUgc29saWQgeC12YWx1ZXMgbGlrZSBzbzogW1t4MSwgeDJdLCBbeDMsIHg0XV1cclxuXHJcbiAgICAgICAgdmFyIHBhaXJlZF94X3ZhbHMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHhfdmFscy5sZW5ndGg7IHgrKykge1xyXG4gICAgICAgICAgICBpZiAoKHggKyAxKSAlIDIgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcGFpcmVkX3hfdmFscy5wdXNoKFt4X3ZhbHNbeCAtIDFdLCB4X3ZhbHNbeF1dKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGFpcmVkX3h2YWxzLnB1c2gocGFpcmVkX3hfdmFscyk7XHJcblxyXG4gICAgICAgIC8vIGRldGVybWluZSB0aGUgZnVsbCB3aWR0aCBvbiB0aGlzIHktdmFsdWUgYnkgc3VtbWluZyB0aGUgZHggaW4gdGhlIHBhaXJlZCBsaXN0cy5cclxuICAgICAgICB2YXIgd2lkdGggPSAwO1xyXG4gICAgICAgIGZvciAoYSA9IDA7IGEgPCBwYWlyZWRfeF92YWxzLmxlbmd0aDsgYSsrKSB7XHJcbiAgICAgICAgICAgIHdpZHRoICs9IHBhaXJlZF94X3ZhbHNbYV1bMV0gLSBwYWlyZWRfeF92YWxzW2FdWzBdXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMud2lkdGhfYXJyYXkucHVzaChNYXRoLmFicyh3aWR0aCkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblBvbHlHb24ucHJvdG90eXBlLmFyZWEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZHkgPSB0aGlzLnlfdmFsWzFdIDtcclxuICAgIHZhciBhcmVhID0gMDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy55X3ZhbC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGFyZWEgKz0gZHkgKiB0aGlzLndpZHRoX2FycmF5W2ldXHJcbiAgICB9XHJcbiAgICBhcmVhID0gTWF0aC5yb3VuZChhcmVhKSA7XHJcbiAgICByZXR1cm4gTWF0aC5hYnMoYXJlYSlcclxufTtcclxuXHJcblBvbHlHb24ucHJvdG90eXBlLnplcm9fbGluZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBkaCA9ICh0aGlzLnRvcCAtIHRoaXMuYm90dG9tKSAvIHRoaXMubl92YWx1ZTtcclxuICAgIHZhciBzdW1fQV9oID0gMDtcclxuICAgIGZvciAodmFyIGkgaW4gdGhpcy53aWR0aF9hcnJheSkge1xyXG4gICAgICAgIHN1bV9BX2ggKz0gZGggKiB0aGlzLndpZHRoX2FycmF5W2ldICogdGhpcy55X3ZhbFtpXVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN1bV9BX2ggLyB0aGlzLmFyZWEoKVxyXG59O1xyXG5cclxuLy8gZW5kIGNsYXNzXHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIENpcmNsZShyYWRpdXMpIHtcclxuICAgICAgICB2YXIgbiA9IDEwMDtcclxuICAgICAgICB2YXIgYWxwaGEwID0gTWF0aC5QSSAqIDIgLyBuO1xyXG4gICAgICAgIHZhciBwbCA9IFtdO1xyXG4gICAgICAgIHZhciBwMCA9IG5ldyB2ZWN0b3IuUG9pbnQoMCwgLXJhZGl1cyk7XHJcbiAgICAgICAgLy8gdHJhbnNsYXRpb24gcG9pbnQuIERvZXMgbm90aGluZyBlbHNlXHJcbiAgICAgICAgdmFyIHBfc2V0ID0gbmV3IHZlY3Rvci5Qb2ludChyYWRpdXMsIHJhZGl1cyk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IGFscGhhMCAqIGk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgcCA9IHAwLnJvdGF0ZV9vcmlnaW4oYWxwaGEpO1xyXG4gICAgICAgICAgICBwID0gbmV3IHZlY3Rvci5Qb2ludChwLnggKyBwX3NldC54LCBwLnkgKyBwX3NldC55KTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgICBwbC5wdXNoKHApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBQb2x5R29uLmNhbGwodGhpcywgcGwpOyAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxyXG4gICAgfVxyXG5cclxuICAgIENpcmNsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBvbHlHb24ucHJvdG90eXBlKTtcclxuICAgIENpcmNsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaXJjbGU7XHJcblxyXG4gICAgZnVuY3Rpb24gU3VidHJhY3Rvcih0b3AsIHBvaW50X2xpc3QsIG5fdmFsdWUpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gdG9wIChmbG9hdCkgVG9wIG9mIHRoZSBwYXJlbnQgY3Jvc3Mgc2VjdGlvbiAoeS12YWx1ZSlcclxuICAgICAgICAgKiBAcGFyYW0gbl92YWx1ZSAoaW50KSBBbW91bnQgb2Ygc2VjdGlvbiBpbiB0aGUgcGFyZW50IGNyb3NzIHNlY3Rpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBvaW50X2xpc3QgPSBwb2ludF9saXN0O1xyXG4gICAgICAgIHRoaXMucGFpcmVkX3h2YWxzID0gW107XHJcbiAgICAgICAgdGhpcy53aWR0aF9hcnJheSA9IFtdO1xyXG4gICAgICAgIHRoaXMudG9wID0gdG9wO1xyXG4gICAgICAgIHRoaXMubl92YWx1ZSA9IG5fdmFsdWU7XHJcbiAgICAgICAgdGhpcy55X3ZhbCA9IHRoaXMuZGV0X2hlaWdodF9hcnJheSgpO1xyXG4gICAgICAgIHRoaXMucmV0dXJuX3hfb25fYXhpcygpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBTdWJ0cmFjdG9yLnByb3RvdHlwZS5tZXJnZV93aWR0aCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gcGFyZW50IE9iamVjdCBmcm9tIHRoZSBwYXJlbnQgY3Jvc3Mgc2VjdGlvbi5cclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSBpbiBwYXJlbnQud2lkdGhfYXJyYXkpIHtcclxuICAgICAgICAgICAgcGFyZW50LndpZHRoX2FycmF5W2ldIC09IHRoaXMud2lkdGhfYXJyYXlbaV07XHJcblxyXG4gICAgICAgICAgICAvLyBtZXJnZSB0aGUgcGFpcmVkIHhfdmFscyAoZm9yIHRoZSBwbG90dGVyKVxyXG4gICAgICAgICAgICB2YXIgeF92YWxzID0gW107XHJcbiAgICAgICAgICAgIGlmICh0aGlzLndpZHRoX2FycmF5W2ldID4gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vdW5wYWNrIHBhcmVudHMgcGFpcmVkIHhfdmFsc1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiBpbiBwYXJlbnQucGFpcmVkX3h2YWxzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeF92YWxzLnB1c2gocGFyZW50LnBhaXJlZF94dmFsc1tpXVtqXVswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgeF92YWxzLnB1c2gocGFyZW50LnBhaXJlZF94dmFsc1tpXVtqXVsxXSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHVucGFjayBzdWJ0cmFjdG9ycyBwYWlyZWQgeF92YWxzXHJcbiAgICAgICAgICAgICAgICBmb3IgKGogaW4gdGhpcy5wYWlyZWRfeHZhbHNbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB4X3ZhbHMucHVzaCh0aGlzLnBhaXJlZF94dmFsc1tpXVtqXVswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgeF92YWxzLnB1c2godGhpcy5wYWlyZWRfeHZhbHNbaV1bal1bMV0pXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgeF92YWxzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgLSBiIH0pO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVwYWNrIHRoZW1cclxuICAgICAgICAgICAgICAgIHZhciBwYWlyZWRfeF92YWxzID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHhfdmFscy5sZW5ndGg7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoeCArIDEpICUgMiA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhaXJlZF94X3ZhbHMucHVzaChbeF92YWxzW3ggLSAxXSwgeF92YWxzW3hdXSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQucGFpcmVkX3h2YWxzW2ldID0gcGFpcmVkX3hfdmFsc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBTdWJ0cmFjdG9yLnByb3RvdHlwZS5yZXR1cm5feF9vbl9heGlzID0gUG9seUdvbi5wcm90b3R5cGUucmV0dXJuX3hfb25fYXhpcztcclxuICAgIFN1YnRyYWN0b3IucHJvdG90eXBlLmRldF9oZWlnaHRfYXJyYXkgPSBQb2x5R29uLnByb3RvdHlwZS5kZXRfaGVpZ2h0X2FycmF5O1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBUdWJlKHJhZGl1c19vdXQsIHJhZGl1c19pbikge1xyXG4gICAgICAgIHZhciBuID0gMTAwO1xyXG4gICAgICAgIHZhciBhbHBoYTAgPSBNYXRoLlBJICogMiAvIG47XHJcbiAgICAgICAgdmFyIHBsX291dCA9IFtdO1xyXG4gICAgICAgIHZhciBwbF9pbiA9IFtdO1xyXG4gICAgICAgIHZhciBwMF9vdXQgPSBuZXcgdmVjdG9yLlBvaW50KDAsIC1yYWRpdXNfb3V0KTtcclxuICAgICAgICB2YXIgcDBfaW4gPSBuZXcgdmVjdG9yLlBvaW50KDAsIC1yYWRpdXNfaW4pO1xyXG5cclxuICAgICAgICAvLyBUcmFuc2xhdGlvbiBwb2ludHMuIERvIG5vdGhpbmcgZWxzZVxyXG4gICAgICAgIHZhciBwX3NldF9pbiA9IG5ldyB2ZWN0b3IuUG9pbnQocmFkaXVzX291dCwgcmFkaXVzX291dCk7XHJcbiAgICAgICAgdmFyIHBfc2V0X291dCA9IG5ldyB2ZWN0b3IuUG9pbnQocmFkaXVzX291dCwgcmFkaXVzX291dCk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG4gKyAxOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGFscGhhID0gYWxwaGEwICogaTtcclxuICAgICAgICAgICAgdmFyIHBfb3V0ID0gcDBfb3V0LnJvdGF0ZV9vcmlnaW4oYWxwaGEpO1xyXG4gICAgICAgICAgICBwX291dCA9IG5ldyB2ZWN0b3IuUG9pbnQocF9vdXQueCArIHBfc2V0X291dC54LCBwX291dC55ICsgcF9zZXRfb3V0LnkpO1xyXG4gICAgICAgICAgICB2YXIgcF9pbiA9IHAwX2luLnJvdGF0ZV9vcmlnaW4oYWxwaGEpO1xyXG4gICAgICAgICAgICBwX2luID0gbmV3IHZlY3Rvci5Qb2ludChwX2luLnggKyBwX3NldF9pbi54LCBwX2luLnkgKyBwX3NldF9pbi55KTtcclxuXHJcbiAgICAgICAgICAgIHBsX291dC5wdXNoKHBfb3V0KTtcclxuICAgICAgICAgICAgcGxfaW4ucHVzaChwX2luKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgUG9seUdvbi5jYWxsKHRoaXMsIHBsX291dCk7XHJcblxyXG4gICAgICAgIHRoaXMuc3VidHJhY3RvciA9IG5ldyBTdWJ0cmFjdG9yKHJhZGl1c19vdXQgKiAyLCBwbF9pbiwgdGhpcy5uX3ZhbHVlKTtcclxuICAgICAgICB0aGlzLnN1YnRyYWN0b3IubWVyZ2Vfd2lkdGgodGhpcylcclxuICAgIH1cclxuXHJcbiAgICBUdWJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUG9seUdvbi5wcm90b3R5cGUpO1xyXG4gICAgVHViZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUdWJlO1xyXG5cclxuXHJcblxyXG5cclxuLy8gcmV0dXJuIGZyb20gbmFtZXNwYWNlXHJcbnJldHVybiB7XHJcbiAgICBQb2x5R29uOiBQb2x5R29uLFxyXG4gICAgQ2lyY2xlOiBDaXJjbGUsXHJcbiAgICBUdWJlOiBUdWJlLFxyXG4gICAgU3VidHJhY3RvcjogU3VidHJhY3RvclxyXG59XHJcbiAgICBcclxufSkoKTsgIC8vIGNyc24gbmFtZXNwYWNlXHJcbid1c2Ugc3RyaWN0JztcclxudmFyIERFQlVHID0gZmFsc2U7XHJcbi8vIG1rYXAgbmFtZXNwYWNlXHJcbnZhciBta2FwID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAvL2NsYXNzXHJcbiAgICBmdW5jdGlvbiBNb21lbnRLYXBwYShjcm9zc19zZWN0aW9uLCBjb21wcmVzc2l2ZV9kaWFncmFtLCB0ZW5zaWxlX2RpYWdyYW0pIHtcclxuICAgICAgICB0aGlzLmNyb3NzX3NlY3Rpb24gPSBjcm9zc19zZWN0aW9uO1xyXG4gICAgICAgIHRoaXMuY29tcHJlc3NpdmVfZGlhZ3JhbSA9IGNvbXByZXNzaXZlX2RpYWdyYW07XHJcbiAgICAgICAgdGhpcy50ZW5zaWxlX2RpYWdyYW0gPSB0ZW5zaWxlX2RpYWdyYW07XHJcbiAgICAgICAgLy8gc3VtIG9mIHRoZSBmb3JjZXMgaW4gdGhlIGNyb3NzIHNlY3Rpb25cclxuICAgICAgICB0aGlzLmZvcmNlX3RlbnNpbGUgPSAwO1xyXG4gICAgICAgIHRoaXMuZm9yY2VfY29tcHJlc3Npb24gPSAwO1xyXG4gICAgICAgIHRoaXMubm9ybWFsX2ZvcmNlID0gMDtcclxuICAgICAgICB0aGlzLml0ZXJhdGlvbnMgPSAyNTA7XHJcbiAgICAgICAgdGhpcy5kaXYgPSAzO1xyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICogUmVpbmZvcmNlbWVudC5cclxuICAgICAgICAqIEZvciBuIGxheWVycyBvZiByZWluZm9yY2VtZW50LCBuIHBhcmFtZXRlcnMgbmVlZCB0byBiZSBpbml0aWF0ZWQgaW4gdGhlIGFycmF5cy5cclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmViYXJfQXMgPSBbXTtcclxuICAgICAgICAvLyBkaXN0YW5jZSByZWJhciBmcm9tIHRoZSBib3R0b20gb2YgdGhlIG1hc3RlciBjcm9zcyBzZWN0aW9uXHJcbiAgICAgICAgdGhpcy5yZWJhcl96ID0gW107XHJcbiAgICAgICAgLy8gb2JqZWN0cyBmcm9tIHRoZSBTdHJlc3NTdHJhaW4gY2xhc3NcclxuICAgICAgICB0aGlzLnJlYmFyX2RpYWdyYW0gPSBbXTtcclxuICAgICAgICAvLyBwaGFzZWQgcmViYXJcclxuICAgICAgICB0aGlzLm0wID0gW107XHJcbiAgICAgICAgdGhpcy5yZWJhcl9zdHJhaW4wX3BsdCA9IFtdO1xyXG4gICAgICAgIHRoaXMucmViYXJfZGlhbSA9IG51bGw7ICAvLyBmb3IgdGhlIHBsb3R0ZXJcclxuXHJcbiAgICAgICAgLy8gQXBwbGllZCBhdCB0PTAuICd3ZXJrdm9vcnNwYW5uaW5nJ1xyXG4gICAgICAgIHRoaXMucHJlc3RyZXNzID0gW107XHJcblxyXG4gICAgICAgIC8vIFN0cmVzcyBhbmQgc3RyYWluIGluIHRoZSByZWluZm9yY2VtZW50IGFmdGVyIE1wIGhhcyBiZWVuIGFwcGxpZWQgYW5kIHRoZSBkZWZvcm1hdGlvbiBpcyB6ZXJvLlxyXG4gICAgICAgIHRoaXMuZF9zdHJlc3MgPSBbXTtcclxuICAgICAgICB0aGlzLmRfc3RyYWluID0gW107XHJcbiAgICAgICAgdGhpcy5tcCA9IDA7XHJcbiAgICAgICAgLy8gVXNlZCBieSBzZXNzaW9uLmpzIHdoZW4gcHJlc3RyZXNzIGlzIGFwcGxpZWQuXHJcbiAgICAgICAgdGhpcy5vcmlnaW5hbF9yZWJhcl9kaWFncmFtcyA9IFtdO1xyXG5cclxuICAgIFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgIHJlc3VsdHNcclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc29sdXRpb24gPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmViYXJfZm9yY2UgPSBbXTtcclxuICAgICAgICB0aGlzLnJlYmFyX3N0cmFpbiA9IFtdO1xyXG4gICAgICAgIHRoaXMuc3RyZXNzID0gW107XHJcbiAgICAgICAgdGhpcy5tb21lbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMua2FwcGEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc3RyYWluX3RvcCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zdHJhaW5fYnRtID0gbnVsbDtcclxuICAgICAgICB0aGlzLnplcm9fbGluZSA9IG51bGwgOyAvLyB4dSBpcyBoZWlnaHQgLSB6ZXJvIGxpbmVcclxuICAgICAgICB0aGlzLnh1ID0gbnVsbDtcclxuXHJcbiAgICAgICAgdGhpcy5yZWR1Y2VfcmViYXIgPSBmYWxzZVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBNb21lbnRLYXBwYS5wcm90b3R5cGUuZGV0X2ZvcmNlX2Rpc3RyaWJ1dGlvbiA9IGZ1bmN0aW9uIChzdHJhaW5fdG9wLCBzdHJhaW5fYnRtLCByZWR1Y2VfcmViYXIpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdW0gdGhlIHRlbnNpbGUgYW5kIGNvbXByZXNzaW9uIGZvcmNlcyBiYXNlZCBvbiB0aGUgc3RyYWluIGRpc3RyaWJ1dGlvblxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHN0cmFpbl90b3A6IChmbG9hdCkgU3RyYWluIGF0IHRoZSB0b3Agb2YgdGhlIGNyb3NzIHNlY3Rpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHN0cmFpbl9idG06IChmbG9hdCkgU3RyYWluIGF0IHRoZSBib3R0b20gb2YgdGhlIGNyb3NzIHNlY3Rpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHJlZHVjZV9yZWJhcjogKGJvb2wpIFN1YnRyYWN0IHRoZSByZWluZm9yY2VtZW50IGNyb3NzIHNlY3Rpb24gb2YgdGhlIHdob2xlIGNyb3NzIHNlY3Rpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZvcmNlX2NvbXByZXNzaW9uID0gMDtcclxuICAgICAgICB0aGlzLmZvcmNlX3RlbnNpbGUgPSAwO1xyXG4gICAgICAgIHRoaXMuc3RyZXNzID0gW107XHJcbiAgICAgICAgdGhpcy5yZWJhcl9zdHJhaW4gPSBbXTtcclxuICAgICAgICB0aGlzLnN0cmFpbl90b3AgPSBzdHJhaW5fdG9wO1xyXG4gICAgICAgIHRoaXMuc3RyYWluX2J0bSA9IHN0cmFpbl9idG07XHJcblxyXG4gICAgICAgIC8vIGRlZmF1bHQgcGFyYW1ldGVyXHJcbiAgICAgICAgcmVkdWNlX3JlYmFyID0gKHR5cGVvZiByZWR1Y2VfcmViYXIgIT09IFwidW5kZWZpbmVkXCIpID8gcmVkdWNlX3JlYmFyIDogZmFsc2U7XHJcbiAgICAgICAgdGhpcy5yZWR1Y2VfcmViYXIgPSByZWR1Y2VfcmViYXI7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm5vcm1hbF9mb3JjZSA8IDApIHtcclxuICAgICAgICAgICAgdGhpcy5mb3JjZV90ZW5zaWxlICs9IE1hdGguYWJzKHRoaXMubm9ybWFsX2ZvcmNlKVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5mb3JjZV9jb21wcmVzc2lvbiArPSBNYXRoLmFicyh0aGlzLm5vcm1hbF9mb3JjZSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGhlaWdodCBvZiB0aGUgc2VjdGlvbnNcclxuICAgICAgICB2YXIgZGggPSB0aGlzLmNyb3NzX3NlY3Rpb24ueV92YWxbMV07XHJcblxyXG4gICAgICAgIC8vY3Jvc3Mgc2VjdGlvblxyXG4gICAgICAgIHZhciBjcnNfYnRtID0gdGhpcy5jcm9zc19zZWN0aW9uLnlfdmFsWzBdO1xyXG4gICAgICAgIHZhciBjcnNfdG9wID0gdGhpcy5jcm9zc19zZWN0aW9uLnlfdmFsW3RoaXMuY3Jvc3Nfc2VjdGlvbi55X3ZhbC5sZW5ndGggLSAxXTtcclxuXHJcbiAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIHRoZSB5LWF4aXMgb2YgdGhlIG1hc3RlciBjcm9zcyBzZWN0aW9uIGFuZCBkZXRlcm1pbmUgdGhlIHN0cmVzc2VzLlxyXG4gICAgICAgIC8vIHktYXhpcyBzdGFydHMgYXQgYm90dG9tLlxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jcm9zc19zZWN0aW9uLnlfdmFsLmxlbmd0aDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBpbnRlcnBvbGF0ZSB0aGUgc3RyYWluIGF0IHRoaXMgeS12YWx1ZVxyXG4gICAgICAgICAgICB2YXIgc3RyYWluX3kgPSBzdGQuaW50ZXJwb2xhdGUoY3JzX2J0bSwgc3RyYWluX2J0bSxcclxuICAgICAgICAgICAgICAgIGNyc190b3AsIHN0cmFpbl90b3AsIHRoaXMuY3Jvc3Nfc2VjdGlvbi55X3ZhbFtpXSk7XHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgICAgICAvLyBTZW5kIHRoZSBzdHJhaW4gdmFsdWUgYXMgcGFyYW1ldGVyIGluIHRoZSBzdHJlc3Mgc3RyYWluIGRpYWdyYW1cclxuICAgICAgICAgICAgaWYgKHN0cmFpbl95IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgc3RyZXNzID0gLXRoaXMuY29tcHJlc3NpdmVfZGlhZ3JhbS5kZXRfc3RyZXNzKE1hdGguYWJzKHN0cmFpbl95KSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZvcmNlX2NvbXByZXNzaW9uIC09IHN0cmVzcyAqIHRoaXMuY3Jvc3Nfc2VjdGlvbi53aWR0aF9hcnJheVtpXSAqIGRoXHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0cmVzcyA9IHRoaXMudGVuc2lsZV9kaWFncmFtLmRldF9zdHJlc3Moc3RyYWluX3kpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mb3JjZV90ZW5zaWxlICs9IHN0cmVzcyogdGhpcy5jcm9zc19zZWN0aW9uLndpZHRoX2FycmF5W2ldICogZGhcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0cmVzcy5wdXNoKHN0cmVzcylcclxuICAgICAgICB9XHJcblxyXG4gICAgXHJcbiAgICAgICAgLy8gZGV0ZXJtaW5lIHJlaW5mb3JjZW1lbnQgZm9yY2VzXHJcbiAgICAgICAgdGhpcy5yZWJhcl9mb3JjZSA9IFtdO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnJlYmFyX0FzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHJhaW4gPSBzdGQuaW50ZXJwb2xhdGUoY3JzX2J0bSwgc3RyYWluX2J0bSwgY3JzX3RvcCwgc3RyYWluX3RvcCwgdGhpcy5yZWJhcl96W2ldKTtcclxuICAgICAgICAgICAgdGhpcy5yZWJhcl9zdHJhaW4ucHVzaChzdHJhaW4gKyB0aGlzLmRfc3RyYWluW2ldKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdHJlc3MgPSB0aGlzLnJlYmFyX2RpYWdyYW1baV0uZGV0X3N0cmVzcyhNYXRoLmFicyhzdHJhaW4pKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGFic29sdXRlIHZhbHVlXHJcbiAgICAgICAgICAgIHZhciBmb3JjZSA9IHRoaXMucmViYXJfQXNbaV0gKiBzdHJlc3M7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBzdHJlc3NfcmVkdWN0O1xyXG4gICAgICAgICAgICBpZiAoc3RyYWluIDwgMCAmJiB0aGlzLnByZXN0cmVzc1tpXSA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZvcmNlX2NvbXByZXNzaW9uICs9IGZvcmNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWJhcl9mb3JjZS5wdXNoKC1mb3JjZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHJlZHVjZV9yZWJhcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IHJlaW5mb3JjZW1lbnQgYXJlYSBmcm9tIG1hc3RlciBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyZXNzX3JlZHVjdCA9IHRoaXMuY29tcHJlc3NpdmVfZGlhZ3JhbS5kZXRfc3RyZXNzKE1hdGguYWJzKHN0cmFpbikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VfY29tcHJlc3Npb24gLT0gdGhpcy5yZWJhcl9Bc1tpXSAqIHN0cmVzc19yZWR1Y3RcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VfdGVuc2lsZSArPSBmb3JjZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmViYXJfZm9yY2UucHVzaChmb3JjZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHJlZHVjZV9yZWJhcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IHJlaW5mb3JjZW1lbnQgYXJlYSBmcm9tIG1hc3RlciBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyZXNzX3JlZHVjdCA9IHRoaXMudGVuc2lsZV9kaWFncmFtLmRldF9zdHJlc3Moc3RyYWluKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcmNlX3RlbnNpbGUgLT0gdGhpcy5yZWJhcl9Bc1tpXSAqIHN0cmVzc19yZWR1Y3RcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIE1vbWVudEthcHBhLnByb3RvdHlwZS5zZXRfZGl2ID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXAgdGhlIGFsbG93ZWQgaXRlcmF0aW9ucyBhdCBzbWFsbCBzdHJhaW5zLiBEdWUgdG8gYXN5bXB0b3RpYyBiZWhhdmlvdXIgdGhlcmUgYXJlIG1vcmUgaXRlcmF0aW9ucyBuZWVkZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gc3RyOiAoZmxvYXQpIFN0cmFpbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBpZiAoTWF0aC5hYnMoc3RyKSA8IDAuMTUpIHtcclxuICAgICAgICAgICAgdGhpcy5pdGVyYXRpb25zID0gNTAwXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLml0ZXJhdGlvbnMgPSAyNTA7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBNb21lbnRLYXBwYS5wcm90b3R5cGUuaXRlcmF0b3JfdG9wX2NvbnN0YW50ID0gZnVuY3Rpb24gKGJ0bV9zdHIsIHRvcF9zdHIpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gYnRtX3N0cjogKGZsb2F0KSBzdHJhaW4gdG8gc3RhcnRcclxuICAgICAgICAgKiBAcGFyYW0gdG9wX3N0cjogKGZsb2F0KSBzdHJhaW4gdG8gc3RhcnRcclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIHJlaW5mb3JjZW1lbnQgaXMgYWJvdmUgdGhlIHplcm8gbGluZSwgdGhlcmUgd2lsbCBzb21ldGltZXMgYmUgbm8gdGVuc2lsZSBmb3JjZVxyXG4gICAgICAgIC8vIEZpbmQgdGhlIGluZGV4IG9mIHRoZSBoaWdoZXN0IHJlaW5mb3JjZW1lbnQgbGF5ZXIuXHJcbiAgICAgICAgdmFyIHRvcF9yZWluZiA9IE1hdGgubWluLmFwcGx5KG51bGwsIHRoaXMucmViYXJfeik7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlYmFyX0FzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYmFyX3pbaV0gPT0gdG9wX3JlaW5mKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmJyX2luZGV4ID0gaVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY291bnQgPSAwO1xyXG4gICAgICAgIC8vIGl0ZXJhdGUgdW50aWwgdGhlIGNvbnZlcmdlbmNlIGNyaXRlcmlhIGlzIG1ldFxyXG4gICAgICAgIHdoaWxlICgxKSB7XHJcbiAgICAgICAgICAgIGlmIChzdGQuY29udmVyZ2VuY2VfY29uZGl0aW9ucyh0aGlzLmZvcmNlX2NvbXByZXNzaW9uLCB0aGlzLmZvcmNlX3RlbnNpbGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNvbHV0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbnZlcmdlbmNlIGFmdGVyICVzIGl0ZXJhdGlvbnNcIi5yZXBsYWNlKFwiJXNcIiwgY291bnQpKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBbMCwgY291bnRdOyAvLyBbc3VjY2VzcywgY291bnRdXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEV4dHJhcG9sYXRlIHRoZSBzdHJhaW4gZnJvbSB0aGUgZmlyc3Qgc2lnbmlmaWNhbnQgcmViYXIgc3RyYWluIHBvaW50LCB0byB0aGUgYm90dG9tIHN0cmFpbi5cclxuICAgICAgICAgICAgLy8gTmVlZGVkIHdoZW4gdGhlIHJlYmFyIGlzIGFib3ZlIHRoZSBuZXV0cmFsIGxpbmUuXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTmFOKHRoaXMuZm9yY2VfdGVuc2lsZSkgfHwgdGhpcy5mb3JjZV90ZW5zaWxlID09IDApIHtcclxuICAgICAgICAgICAgICAgIGJ0bV9zdHIgPSBzdGQuaW50ZXJwb2xhdGUodGhpcy5jcm9zc19zZWN0aW9uLnRvcCwgdG9wX3N0ciwgdG9wX3JlaW5mLCB0aGlzLnJlYmFyX2RpYWdyYW1bcmJyX2luZGV4XS5zdHJhaW5bMV0sIHRoaXMuY3Jvc3Nfc2VjdGlvbi5ib3R0b20pXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZm9yY2VfdGVuc2lsZSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0X2RpdihidG1fc3RyKTtcclxuICAgICAgICAgICAgICAgIHZhciBmYWN0b3IgPSBzdGQuY29udmVyZ2VuY2UodGhpcy5mb3JjZV90ZW5zaWxlLCB0aGlzLmZvcmNlX2NvbXByZXNzaW9uLCB0aGlzLmRpdik7XHJcbiAgICAgICAgICAgICAgICBidG1fc3RyID0gYnRtX3N0ciAqIGZhY3RvcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5kZXRfZm9yY2VfZGlzdHJpYnV0aW9uKHRvcF9zdHIsIGJ0bV9zdHIpO1xyXG4gICAgICAgICAgICBpZiAoY291bnQgPiB0aGlzLml0ZXJhdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibm8gY29udmVyZ2VuY2UgZm91bmQgYWZ0ZXIgJXMgaXRlcmF0aW9uc1wiLnJlcGxhY2UoXCIlc1wiLCBjb3VudCkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWzEsIGNvdW50XTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY291bnQgKz0gMVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTW9tZW50S2FwcGEucHJvdG90eXBlLml0ZXJhdG9yX2J0bV9jb25zdGFudCA9IGZ1bmN0aW9uIChidG1fc3RyLCB0b3Bfc3RyKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIGJ0bV9zdHI6IChmbG9hdCkgc3RyYWluIHRvIHN0YXJ0XHJcbiAgICAgICAgICogQHBhcmFtIHRvcF9zdHI6IChmbG9hdCkgc3RyYWluIHRvIHN0YXJ0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcclxuICAgICAgICAvLyBpdGVyYXRlIHVudGlsIHRoZSBjb252ZXJnZW5jZSBjcml0ZXJpYSBpcyBtZXRcclxuICAgICAgICB3aGlsZSAoMSkge1xyXG4gICAgICAgICAgICBpZiAoc3RkLmNvbnZlcmdlbmNlX2NvbmRpdGlvbnModGhpcy5mb3JjZV9jb21wcmVzc2lvbiwgdGhpcy5mb3JjZV90ZW5zaWxlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zb2x1dGlvbiA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb252ZXJnZW5jZSBhZnRlciAlcyBpdGVyYXRpb25zXCIucmVwbGFjZShcIiVzXCIsIGNvdW50KSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBbMCwgY291bnRdXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBmYWN0b3IgPSBzdGQuY29udmVyZ2VuY2UodGhpcy5mb3JjZV9jb21wcmVzc2lvbiwgdGhpcy5mb3JjZV90ZW5zaWxlLCB0aGlzLmRpdik7XHJcbiAgICAgICAgICAgIHRvcF9zdHIgPSB0b3Bfc3RyICogZmFjdG9yO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5kZXRfZm9yY2VfZGlzdHJpYnV0aW9uKHRvcF9zdHIsIGJ0bV9zdHIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvdW50ID4gdGhpcy5pdGVyYXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIm5vIGNvbnZlcmdlbmNlIGZvdW5kIGFmdGVyICVzIGl0ZXJhdGlvbnNcIi5yZXBsYWNlKFwiJXNcIiwgY291bnQpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsxLCBjb3VudF1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb3VudCArPSAxXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBNb21lbnRLYXBwYS5wcm90b3R5cGUuaXRlcmF0b3JfY29tcGxldGVfcHJlc3N1cmUgPSBmdW5jdGlvbiAodG9wX3N0cikge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbXByZXNzaW9uIGluIGJvdHRvbSBtYXkgbm90IGJlIGhpZ2hlciB0aGFuIGluIHRvcC5cclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgdmFyIGJ0bV9zdHIgPSB0b3Bfc3RyO1xyXG5cclxuICAgICAgICB0aGlzLmRldF9mb3JjZV9kaXN0cmlidXRpb24odG9wX3N0ciwgYnRtX3N0cik7XHJcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VfdGVuc2lsZSA+IHRoaXMuZm9yY2VfY29tcHJlc3Npb24pIHtcclxuICAgICAgICAgICAgLy8gTm8gZXF1aWxpYnJpdW0gcG9zc2libGUgd2l0aCBwb3NpdGl2ZSBrYXBwYS5cclxuICAgICAgICAgICAgcmV0dXJuIDFcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjb3VudCA9IDA7XHJcbiAgICAgICAgLy8gaXRlcmF0ZSB1bnRpbCB0aGUgY29udmVyZ2VuY2UgY3JpdGVyaWEgaXMgbWV0XHJcblxyXG4gICAgICAgIHdoaWxlICgxKSB7XHJcbiAgICAgICAgICAgIGlmIChzdGQuY29udmVyZ2VuY2VfY29uZGl0aW9ucyh0aGlzLmZvcmNlX2NvbXByZXNzaW9uLCB0aGlzLmZvcmNlX3RlbnNpbGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNvbHV0aW9uID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbnZlcmdlbmNlIGFmdGVyICVzIGl0ZXJhdGlvbnNcIi5yZXBsYWNlKFwiJXNcIiwgY291bnQpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFswLCBjb3VudF1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRfZGl2KGJ0bV9zdHIpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGZhY3RvciA9IHN0ZC5jb252ZXJnZW5jZSh0aGlzLmZvcmNlX2NvbXByZXNzaW9uLCB0aGlzLmZvcmNlX3RlbnNpbGUsIHRoaXMuZGl2KTtcclxuICAgICAgICAgICAgYnRtX3N0ciA9IGJ0bV9zdHIgKiBmYWN0b3I7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRldF9mb3JjZV9kaXN0cmlidXRpb24odG9wX3N0ciwgYnRtX3N0cik7XHJcblxyXG4gICAgICAgICAgICBpZiAoY291bnQgPiB0aGlzLml0ZXJhdGlvbnMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIm5vIGNvbnZlcmdlbmNlIGZvdW5kIGFmdGVyICVzIGl0ZXJhdGlvbnNcIi5yZXBsYWNlKFwiJXNcIiwgY291bnQpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsxLCBjb3VudF1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb3VudCArPSAxXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgTW9tZW50S2FwcGEucHJvdG90eXBlLnNvbHZlciA9IGZ1bmN0aW9uIChzdHJhaW5fdG9wLCBzdHJhaW4pIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gdGhlIC5kZXRfc3RyZXNzIG1ldGhvZCBzZXZlcmFsIHRpbWVzIGFuZCBhZGFwdCB0aGUgaW5wdXQgdW50aWwgdGhlIGNvbnZlcmdlbmNlIGNyaXRlcmlhIGlzIG1ldC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBzdHJhaW5fdG9wOiAoYm9vbCkgQ29uc3RhbnQgc3RyYWluIGF0IHRoZSB0b3AuIElmIHRydWUsIHRoZSBzdHJhaW4gYXQgdGhlIHRvcCB3aWxsIHJlbWFpbiBjb25zdGFudFxyXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgIGFuZCB0aGUgc3RyYWluIGF0IHRoZSBib3R0b20gd2lsbCBiZSBpdGVyYXRlZCBvdmVyLiBJZiBmYWxzZSB2aWNlIHZlcnNhIGZvciBzdHJhaW5fYm90dG9tLlxyXG4gICAgICAgICAqIEBwYXJhbSBzdHJhaW46IChmbG9hdCkgQ29uc3RhbnQgc3RyYWluIGF0IHRoZSB0b3Agb3IgYm90dG9tLlxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICAvLyBkZWZhdWx0IHBhcmFtZXRlclxyXG4gICAgICAgIHN0cmFpbl90b3AgPSAodHlwZW9mIHN0cmFpbl90b3AgIT09IFwidW5kZWZpbmVkXCIpID8gc3RyYWluX3RvcCA6IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuc29sdXRpb24gPSBmYWxzZTtcclxuICAgICAgICB2YXIgdG90YWxfaXRlciA9IDA7XHJcblxyXG4gICAgICAgIC8vIGZpcnN0IGl0ZXJhdGlvblxyXG4gICAgICAgIHZhciBidG1fc3RyID0gc3RyYWluO1xyXG4gICAgICAgIHZhciB0b3Bfc3RyID0gLXN0cmFpbjtcclxuICAgICAgICB0aGlzLmRldF9mb3JjZV9kaXN0cmlidXRpb24odG9wX3N0ciwgYnRtX3N0cik7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBheGlhbCBmb3JjZSBpcyBzdWJzdGFudGlhbCBzdGFydCB3aXRoIGEgc29sdmVyIGNvbXBsZXRlbHkgdW5kZXIgcHJlc3N1cmUuXHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLmNvbXByZXNzaXZlX2RpYWdyYW0uZGV0X3N0cmVzcygtdG9wX3N0cikgKiB0aGlzLmNyb3NzX3NlY3Rpb24uYXJlYSgpICogMC43NTtcclxuICAgICAgICBpZiAoLXRoaXMubm9ybWFsX2ZvcmNlID4gYSkge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUcnkgdG8gc29sdmUgZm9yIGEgY3Jvc3Mgc2VjdGlvbiBjb21wbGV0ZWx5IHVuZGVyIHByZXNzdXJlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgc29sID0gdGhpcy5pdGVyYXRvcl9jb21wbGV0ZV9wcmVzc3VyZSh0b3Bfc3RyKTtcclxuICAgICAgICAgICAgICAgIGlmIChzb2xbMF0gPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29sWzFdXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3RhbF9pdGVyICs9IHNvbFsxXVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyYWluX3RvcCkgeyAgLy8gdG9wIHN0cmFpbiByZW1haW5zIGNvbnN0YW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb2wgPSB0aGlzLml0ZXJhdG9yX3RvcF9jb25zdGFudChidG1fc3RyLCB0b3Bfc3RyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvbFswXSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvbFsxXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxfaXRlciArPSBzb2xbMV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gYm90dG9tIHN0cmFpbiByZW1haW5zIGNvbnN0YW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvbCA9IHRoaXMuaXRlcmF0b3JfYnRtX2NvbnN0YW50KGJ0bV9zdHIsIHRvcF9zdHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc29sWzBdID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29sWzFdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbF9pdGVyICs9IHNvbFsxXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU3RhbmRhcmQgY29udHJvbCBmbG93XHJcbiAgICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoc3RyYWluX3RvcCkgeyAgLy8gdG9wIHN0cmFpbiByZW1haW5zIGNvbnN0YW50XHJcbiAgICAgICAgICAgICAgICB2YXIgc29sID0gdGhpcy5pdGVyYXRvcl90b3BfY29uc3RhbnQoYnRtX3N0ciwgdG9wX3N0cik7XHJcbiAgICAgICAgICAgICAgICBpZiAoc29sWzBdID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvbFsxXVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG90YWxfaXRlciArPSBzb2xbMV1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHsgLy8gYm90dG9tIHN0cmFpbiByZW1haW5zIGNvbnN0YW50XHJcbiAgICAgICAgICAgICAgICBzb2wgPSB0aGlzLml0ZXJhdG9yX2J0bV9jb25zdGFudChidG1fc3RyLCB0b3Bfc3RyKTtcclxuICAgICAgICAgICAgICAgIGlmIChzb2xbMF0gPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29sWzFdXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3RhbF9pdGVyICs9IHNvbFsxXVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMudmFsaWRpdHkoKSAmJiB0aGlzLm5vcm1hbF9mb3JjZSAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRyeSB0byBzb2x2ZSBmb3IgYSBjcm9zcyBzZWN0aW9uIGNvbXBsZXRlbHkgdW5kZXIgcHJlc3N1cmUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICBzb2wgPSB0aGlzLml0ZXJhdG9yX2NvbXBsZXRlX3ByZXNzdXJlKHRvcF9zdHIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNvbFswXSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzb2xbMV1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsX2l0ZXIgKz0gc29sWzFdXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRvdGFsX2l0ZXJcclxuICAgIH07XHJcblxyXG4gICAgTW9tZW50S2FwcGEucHJvdG90eXBlLmRldF9tX2thcHBhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgIERldGVybWluZXMgdGhlIG1vbWVudCBhbmQga2FwcGEgdmFsdWVzLlxyXG4gICAgXHJcbiAgICAgICAgRm9yIGVhY2ggc2VjdGlvbnMgY2VudGVyIG9mIGdyYXZpdHkgdGhlIG1vbWVudCBhcm91bmQgdGhlIG9yaWdpbiBpcyBkZXRlcm1pbmVkLlxyXG4gICAgXHJcbiAgICBcclxuICAgICAgICBfX19fX18gICAgIDwtLS0tIC0gRiBjb21wcmVzc2lvbiBcclxuICAgICAgICB8ICAgICB8ICAgICAgICAgXHJcbiAgICAgICAgfCAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHx5XHJcbiAgICAgICAgfCAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICAgICAgICB8X19fX198ICAgIC0tLS0+ICsgRiB0ZW5zaWxlICAgICAgfDBfX19feFxyXG4gICAgICAgIFxyXG4gICAgICAgICovXHJcblxyXG4gICAgICAgIC8vIGNlbnRlciBvZiBncmF2aXR5IG9mZnNldCBvZiBhIHNlY3Rpb25cclxuICAgICAgICB0aGlzLmthcHBhID0gKC10aGlzLnN0cmFpbl90b3AgKyB0aGlzLnN0cmFpbl9idG0pIC8gKHRoaXMuY3Jvc3Nfc2VjdGlvbi50b3AgLSB0aGlzLmNyb3NzX3NlY3Rpb24uYm90dG9tKTtcclxuICAgICAgICB0aGlzLm1vbWVudCA9IHRoaXMubXA7XHJcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuY3Jvc3Nfc2VjdGlvbi55X3ZhbFsxXSAqIDAuNTtcclxuXHJcbiAgICAgICAgLy8gaGVpZ2h0IG9mIHRoZSBzZWN0aW9uc1xyXG4gICAgICAgIHZhciBkaCA9IHRoaXMuY3Jvc3Nfc2VjdGlvbi55X3ZhbFsxXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNyb3NzX3NlY3Rpb24ueV92YWwubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGFybSA9IHRoaXMuY3Jvc3Nfc2VjdGlvbi55X3ZhbFtpXSArIG9mZnNldDtcclxuICAgICAgICAgICAgdmFyIGZvcmNlID0gdGhpcy5zdHJlc3NbaV0gKiB0aGlzLmNyb3NzX3NlY3Rpb24ud2lkdGhfYXJyYXlbaV0gKiBkaDtcclxuICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLm1vbWVudCArPSBhcm0gKiBmb3JjZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE4gbm9ybWFsIGZvcmNlIHNoYXJlXHJcbiAgICAgICAgdGhpcy5tb21lbnQgLT0gdGhpcy5ub3JtYWxfZm9yY2UgKiB0aGlzLmNyb3NzX3NlY3Rpb24uemVyb19saW5lKCk7XHJcblxyXG4gICAgICAgIC8vIHJlYmFyIHNoYXJlXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMucmViYXJfQXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5tb21lbnQgKz0gdGhpcy5yZWJhcl9mb3JjZVtpXSAqIHRoaXMucmViYXJfeltpXTtcclxuXHJcbiAgICAgICAgICAgIC8vIHJlZHVjdGlvbiBvZiBtYXN0ZXIgY3Jvc3Mgc2VjdGlvbiBhdCBwbGFjZSBvZiByZWJhclxyXG4gICAgICAgICAgICBpZiAodGhpcy5yZWR1Y2VfcmViYXIpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYmFyX2ZvcmNlW2ldID4gMCkgeyAgLy8gdGVuc2lsZSBzdHJlc3NcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyZXNzX3JlZHVjdCA9IHRoaXMudGVuc2lsZV9kaWFncmFtLmRldF9zdHJlc3ModGhpcy5yZWJhcl9zdHJhaW5baV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdGhpcy5tb21lbnQgLT0gc3RyZXNzX3JlZHVjdCAqIHRoaXMucmViYXJfQXNbaV0gKiB0aGlzLnJlYmFyX3pbaV1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgeyAgLy8gY29tcHJlc3Npb24gc3RyZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgc3RyZXNzX3JlZHVjdCA9IC10aGlzLmNvbXByZXNzaXZlX2RpYWdyYW0uZGV0X3N0cmVzcyhNYXRoLmFicyh0aGlzLnJlYmFyX3N0cmFpbltpXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdGhpcy5tb21lbnQgLT0gc3RyZXNzX3JlZHVjdCAqIHRoaXMucmViYXJfQXNbaV0gKiB0aGlzLnJlYmFyX3pbaV1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5tb21lbnQgKj0gLTE7XHJcbiAgICAgICAgLy8gemVybyBsaW5lXHJcbiAgICAgICAgdGhpcy56ZXJvX2xpbmUgPSBzdGQuaW50ZXJwb2xhdGUodGhpcy5zdHJhaW5fYnRtLCB0aGlzLmNyb3NzX3NlY3Rpb24uYm90dG9tLCB0aGlzLnN0cmFpbl90b3AsIHRoaXMuY3Jvc3Nfc2VjdGlvbi50b3AsIDApO1xyXG4gICAgICAgIHRoaXMueHUgPSB0aGlzLmNyb3NzX3NlY3Rpb24udG9wIC0gdGhpcy56ZXJvX2xpbmVcclxuICAgIH07XHJcblxyXG4gICAgTW9tZW50S2FwcGEucHJvdG90eXBlLnZhbGlkaXR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrIGlmIHRoZSBmb3VuZCBlcXVpbGlicml1bSBzb2x1dGlvbiBjb3VsZCBiZSByZWdhcmRlZCBhcyB2YWxpZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciB2YWxpZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKHN0ZC5pc19udW1iZXIodGhpcy5tb21lbnQpXHJcbiAgICAgICAgICAgICYmIHN0ZC5pc19udW1iZXIodGhpcy5rYXBwYSlcclxuICAgICAgICAgICAgJiYgdGhpcy5zb2x1dGlvblxyXG4gICAgICAgICAgICAmJiB0aGlzLnN0cmFpbl90b3AgPj0gLXRoaXMuY29tcHJlc3NpdmVfZGlhZ3JhbS5zdHJhaW5bdGhpcy5jb21wcmVzc2l2ZV9kaWFncmFtLnN0cmFpbi5sZW5ndGggLSAxXVxyXG4gICAgICAgICAgICAmJiB0aGlzLnN0cmFpbl90b3AgPCAwXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMucmViYXJfc3RyYWluKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5yZWJhcl9zdHJhaW5baV0pID4gTWF0aC5tYXguYXBwbHkobnVsbCwgdGhpcy5yZWJhcl9kaWFncmFtW2ldLnN0cmFpbikpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3RkLmlzX2Nsb3NlKHRoaXMuc3RyYWluX2J0bSwgMCwgMC4wMSwgMC4wMSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnh1ID49ICh0aGlzLmNyb3NzX3NlY3Rpb24udG9wIC0gdGhpcy5jcm9zc19zZWN0aW9uLmJvdHRvbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsaWRcclxuICAgIH07XHJcblxyXG4gICAgTW9tZW50S2FwcGEucHJvdG90eXBlLmluc3RhbnRpYXRlX3N0YW5kYXJkX3JlaW5mb3JjZW1lbnQgPSBmdW5jdGlvbihBcywgcmViYXJfeiwgcmViYXJfZGlhZ3JhbSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluc3RhbnRpYXRlIHN0YW5kYXJkIG1vbWVudCBrYXBwYSBzb2x2ZXIuIEJlY2F1c2Ugb2YgdGhlIGV4dHJhIG9wdGlvbnMgcmVnYXJkaW5nIHBoYXNlZCBtb21lbnRzLCBwcmVzdHJlc3NcclxuICAgICAgICAgKiBldGMuIHNvbWUgZXh0cmEgcGFyYW1ldGVycyBuZWVkIHRvIGJlIGluc3RhbnRpYXRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBBczoge0FycmF5fSBBcmVhIG9mIHRoZSByZWluZm9yY2VtZW50IHBlciBsYXllci5cclxuICAgICAgICAgKiBAcGFyYW0gcmViYXJfejoge0FycmF5fSBIZWlnaHQgb2YgdGhlIHJlaW5mb3JjZW1lbnQgbGF5ZXIgd2l0aCByZXNwZWN0IHRvIHRoZSBib3R0b20gb2YgdGhlIGNyb3NzIHNlY3Rpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHJlYmFyX2RpYWdyYW06IHtTdHJlc3NTdHJhaW59IERpYWdyYW0gb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICB0aGlzLnJlYmFyX3ogPSByZWJhcl96O1xyXG4gICAgICAgIHRoaXMucmViYXJfQXMgPSBBcztcclxuXHJcbiAgICAgICAgdGhpcy5wcmVzdHJlc3MgPSB0aGlzLm0wID0gdGhpcy5kX3N0cmVzcyA9IHRoaXMuZF9zdHJhaW4gPVxyXG4gICAgICAgICAgICBBcnJheS5hcHBseShudWxsLCBBcnJheShBcy5sZW5ndGgpKS5tYXAoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mLCAwKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZWJhcl9kaWFncmFtID0gQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkoQXMubGVuZ3RoKSkubWFwKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlYmFyX2RpYWdyYW1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9O1xyXG5cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gU3RyZXNzU3RyYWluKHN0cmFpbiwgc3RyZXNzKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xhc3MgZm9yIGNyZWF0aW5nIHN0cmVzcyBzdHJhaW4gZGlhZ3JhbXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gc3RyYWluOiAoYXJyYXkpIFN0cmFpbiB2YWx1ZXMgb2YgdGhlIGRpYWdyYW0uXHJcbiAgICAgICAgICogQHBhcmFtIHN0cmVzczogKGFycmF5KSBTdHJlc3MgdmFsdWVzIG9mIHRoZSBkaWFncmFtLlxyXG4gICAgICAgICovXHJcblxyXG4gICAgICAgIHRoaXMuc3RyYWluID0gc3RyYWluO1xyXG4gICAgICAgIHRoaXMuc3RyZXNzID0gc3RyZXNzXHJcbiAgICB9XHJcblxyXG5cclxuICAgIFN0cmVzc1N0cmFpbi5wcm90b3R5cGUuZGV0X3N0cmVzcyA9IGZ1bmN0aW9uIChzdHJhaW4pIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gc3RyYWluOiAoZmxvYXQpIFN0cmFpbiBmb3Igd2hpY2ggdGhlIHN0cmVzcyBuZWVkcyB0byBiZSBkZXRlcm1pbmVkLlxyXG4gICAgICAgICAqIEl0ZXJhdGUgdGhyb3VnaCB0aGUgc3RyYWluIGFycmF5IHVudGlsIGl0ZXJhdGVkIHZhbHVlIGV4Y2VlZHMgdGhlIHJlcXVlc3RlZCBzdHJhaW4uXHJcbiAgICAgICAgICogQXQgdGhhdCB0aGUgcG9pbnQgdGhlIHR3byB2YWx1ZXMgd2lsbCBpbnRlcnBvbGF0ZWQuXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdHJhaW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHN0cmFpbiA+IHRoaXMuc3RyYWluW3RoaXMuc3RyYWluLmxlbmd0aCAtIDFdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0cmFpbltpXSA9PSBzdHJhaW4pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVzc1tpXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RyYWluW2ldID4gc3RyYWluKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RkLmludGVycG9sYXRlKHRoaXMuc3RyYWluW2kgLSAxXSwgdGhpcy5zdHJlc3NbaSAtIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyYWluW2ldLCB0aGlzLnN0cmVzc1tpXSwgc3RyYWluKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgU3RyZXNzU3RyYWluLnByb3RvdHlwZS5kZXRfc3RyYWluID0gZnVuY3Rpb24gKHN0cmVzcykge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBzdHJlc3M6IChmbG9hdCkgU3RyYWluIGZvciB3aGljaCB0aGUgc3RyZXNzIG5lZWRzIHRvIGJlIGRldGVybWluZWQuXHJcbiAgICAgICAgICogSXRlcmF0ZSB0aHJvdWdoIHRoZSBzdHJlc3MgYXJyYXkgdW50aWwgaXRlcmF0ZWQgdmFsdWUgZXhjZWVkcyB0aGUgcmVxdWVzdGVkIHN0cmFpbi5cclxuICAgICAgICAgKiBBdCB0aGF0IHRoZSBwb2ludCB0aGUgdHdvIHZhbHVlcyB3aWxsIGludGVycG9sYXRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3RyZXNzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChzdHJlc3MgPiB0aGlzLnN0cmVzc1t0aGlzLnN0cmVzcy5sZW5ndGggLSAxXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zdHJlc3NbaV0gPT0gc3RyZXNzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJhaW5baV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0cmVzc1tpXSA+IHN0cmVzcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0ZC5pbnRlcnBvbGF0ZSh0aGlzLnN0cmVzc1tpIC0gMV0sIHRoaXMuc3RyYWluW2kgLSAxXSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVzc1tpXSwgdGhpcy5zdHJhaW5baV0sIHN0cmVzcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGNhbGNIb29rdXAgKHJlZHVjdGlvbiwgbWthcCwgdG9wKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVkdWN0aW9uIGZhY3RvciAoZmxvYXQpXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBTdGFydHMgdGhlIGNhbGN1bGF0aW9uIHdpdGggdGhlIGxhdGVzdCBwb2ludCBvZiB0aGUgY29tcHJlc3Npb24gbWF0ZXJpYWwgYW5kIHJlZHVjZXMgaXQgdW50aWwgYSBzb2x1dGlvbiBpcyBmb3VuZC5cclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBzdHJhaW4gdGhhdCByZXN1bHRlZCBpbiBhIHZhbGlkIHNvbHV0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHJlZHVjdGlvbjoge2Zsb2F0fSB0aGUgcmVkdWN0aW9uIGZhY3RvciBvZiB0aGUgc3RyYWluLlxyXG4gICAgICAgICAqIEBwYXJhbSBta2FwOiB7b2JqZWN0fSBmcm9tIHRoZSBNb21lbnRLYXBwYSBjbGFzcy5cclxuICAgICAgICAgKiBAcGFyYW0gdG9wOiB7Ym9vbH0gRGVwZW5kcyBpZiB0aGUgaG9va3VwIGlzIHNvdWdodCBmb3IgdGhlIHRvcCBvciB0aGUgYm90dG9tIG9mIHRoZSBjcm9zcyBzZWN0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRvcCA9ICh0eXBlb2YgdG9wICE9PSBcInVuZGVmaW5lZFwiKSA/IHRvcCA6IHRydWU7XHJcbiAgICAgICAgdmFyIHN0cmFpbjtcclxuICAgICAgICBpZiAodG9wKSB7XHJcbiAgICAgICAgICAgIHN0cmFpbiA9IG1rYXAuY29tcHJlc3NpdmVfZGlhZ3JhbS5zdHJhaW5bbWthcC5jb21wcmVzc2l2ZV9kaWFncmFtLnN0cmFpbi5sZW5ndGggLSAxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN0cmFpbiA9IG1rYXAudGVuc2lsZV9kaWFncmFtLnN0cmFpbltta2FwLnRlbnNpbGVfZGlhZ3JhbS5zdHJhaW4ubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBta2FwLnNvbHZlcih0b3AsIHN0cmFpbik7XHJcbiAgICAgICAgbWthcC5kZXRfbV9rYXBwYSgpO1xyXG5cclxuXHJcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcclxuICAgICAgICB3aGlsZSAoIW1rYXAudmFsaWRpdHkoKSAmJiBjb3VudCA8IDE1MCkge1xyXG4gICAgICAgICAgICBta2FwLnNvbHZlcih0b3AsIHN0cmFpbik7XHJcbiAgICAgICAgICAgIG1rYXAuZGV0X21fa2FwcGEoKTtcclxuICAgICAgICAgICAgc3RyYWluICo9ICgxIC0gcmVkdWN0aW9uKTtcclxuICAgICAgICAgICAgY291bnQgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0cmFpblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICByZXR1cm4geyAgICBNb21lbnRLYXBwYTogTW9tZW50S2FwcGEsXHJcbiAgICAgICAgICAgICAgICBTdHJlc3NTdHJhaW46IFN0cmVzc1N0cmFpbixcclxuICAgICAgICAgICAgICAgIGNhbGNIb29rdXA6IGNhbGNIb29rdXBcclxuICAgIH1cclxuXHJcbn0pKCk7ICAvLyBta2FwIG5hbWVzcGFjZVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgc3RkOiBzdGQsXHJcbiAgICBta2FwOiBta2FwLFxyXG4gICAgdmVjdG9yOiB2ZWN0b3IsXHJcbiAgICBjcnNuOiBjcnNuXHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL3ZhbmlsbGFfbWthcC5taW4uanMiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBVUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQWFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBakNBO0FBQ0E7QUFtQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 1 */
/* unknown exports provided */
/* all exports used */
/*!******************************!*\
  !*** ./src/column_nen_en.js ***!
  \******************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mnkappa = __webpack_require__(/*! ./mnkappa.js */ 2);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar vanilla = __webpack_require__(/*! ./vanilla_mkap.min.js */ 0);\n\nvar fyd = 435;\nvar eps_yd = fyd / 2e5;\n\nfunction detM0e(m1, m2) {\n    /*\n     * Determine M0e conform NEN-EN 1992-1-1 art. 5.8.8.2(2).\n     *\n     * @param m1: (float) Bending moment at top or bottom of column.\n     * @param m2: (float) Bending moment at top or bottom of column.\n     * */\n    var m02 = Math.max(m1, m2);\n    var m01 = Math.min(m1, m2);\n    var m0e = 0.6 * m02 + 0.4 * m01;\n    return m0e > 0.4 * m02 ? m0e : 0.4 * m0e;\n}\n\nvar ColumnNENEN = function () {\n    /*\n     * Compute the minimum required column dimension conform NEN-EN.\n     * Units:\n     *  N\n     *  mm\n     *  %\n     *\n     */\n    function ColumnNENEN(m1, m2, ned, fck, rho, l0) {\n        var _this = this;\n\n        _classCallCheck(this, ColumnNENEN);\n\n        this.solve = function () {\n            /*\n             * Solve for the minimum required dimensions. First for Ned. If with these dimensions Med > Mrd, determine\n             * the dimension based on Med.\n             */\n            var fcd = _this.fck / 1.5;\n            var fc = (0, _mnkappa.diagramConcreteBiLinearULS)(fcd);\n            var b = 1000;\n            var c = 0;\n            var area = void 0;\n            var m = void 0;\n            var as = void 0;\n            var nrd = void 0;\n\n            var assign = function assign() {\n                _this.validity = true;\n                _this.width = b;\n                _this.As = as;\n                _this.mrd = m.moment;\n                _this.nrd = nrd;\n            };\n\n            // Iterate the minimum required dimension for the axial force.\n            while (true) {\n                area = Math.pow(b, 2);\n                nrd = _this.axialForceResistance(area);\n                if (vanilla.std.convergence_conditions(nrd, -_this.ned, 1.01, 0.99)) {\n                    as = _this.rho * area / 2;\n                    var cs = (0, _mnkappa.rectangle)(b, b);\n                    m = (0, _mnkappa.m_n_kappa)(cs, fc, _mnkappa.diagramNoConcreteTension, _mnkappa.B500, [as, as], [0.2 * b, 0.8 * b], _this.ned);\n                    (0, _mnkappa.calcHookup)(0.05, m);\n                    m.det_m_kappa();\n                    console.log(\"convergence\", m.moment / 1e6, \"count\", c);\n                    assign();\n                    break;\n                }\n                b *= vanilla.std.convergence(nrd, -_this.ned);\n                c++;\n\n                if (c > 200) {\n                    break;\n                }\n            }\n\n            // Validate if the the minimum required cross section for the axial force is able to bear the total moment.\n            _this.i = b / 3.46;\n            var M2 = _this.det_params(area).M2;\n            var M0EdM2 = Math.max(_this.m0ed + M2, _this.m2, _this.m1 + 0.5 * M2);\n            if (m.moment > M0EdM2) {\n                // The cross section is sufficient.\n                console.log(\"Minimal axial force is sufficient\");\n            } else {\n                c = 0;\n\n                while (true) {\n                    _this.i = b / 3.46;\n                    area = Math.pow(b, 2);\n                    as = _this.rho * area / 2;\n                    var _cs = (0, _mnkappa.rectangle)(b, b);\n\n                    m = (0, _mnkappa.m_n_kappa)(_cs, fc, _mnkappa.diagramNoConcreteTension, _mnkappa.B500, [as, as], [0.2 * b, 0.8 * b], _this.ned);\n                    (0, _mnkappa.calcHookup)(0.05, m);\n                    m.det_m_kappa();\n\n                    var _M = _this.det_params(area).M2;\n                    var _M0EdM = Math.max(_this.m0ed + _M, _this.m2, _this.m1 + 0.5 * _M);\n\n                    var factor = vanilla.std.convergence(m.moment, _M0EdM, 4);\n                    //console.log(\"factor: \", factor);\n                    b *= factor;\n\n                    // if (this.axialForceResistance(area) < -this.ned) {\n                    //     console.log(vanilla.std.convergence(this.axialForceResistance(area), -this.ned), this.axialForceResistance(area)/1e3);\n                    //     console.log(\"minimal axial force dimension\");\n                    //     break\n                    // }\n\n                    if (vanilla.std.convergence_conditions(_M0EdM, m.moment, 1.01, 0.99) && m.validity()) {\n                        console.log(\"convergence\");\n                        assign();\n                        break;\n                    }\n\n                    //console.log(M0EdM2, m.moment, m.validity(), b);\n\n                    if (!isFinite(b)) {\n                        _this.validity = false;\n                        console.log(\"break\");\n                        break;\n                    }\n                    c++;\n\n                    if (c > 250) {\n                        _this.validity = false;\n                        console.log(\"max iter\");\n                        break;\n                    }\n                }\n            }\n        };\n\n        this.m1 = m1;\n        this.m2 = m2;\n        this.ned = ned;\n        this.fck = fck;\n        this.rho = rho;\n        this.l0 = l0;\n        this.m0ed = detM0e(m1, m2);\n\n        this.i = 0; // needs to be determined before det params\n\n        // results\n        this.validity = false;\n        this.width = null;\n        this.As = null;\n    }\n\n    _createClass(ColumnNENEN, [{\n        key: \"det_params\",\n        value: function det_params(area) {\n            /*\n             * Determine the NEN-EN parameters. All the parameters are required to determine M2. These are assigned for\n             * readability.\n             *\n             */\n            // Kr\n            var n = this.ned / (area * this.fck / 1.5);\n            this.as = area * this.rho;\n            this.omega = this.as * fyd / (area * this.fck / 1.5);\n            var n_u = 1 + this.omega;\n            var n_bal = 0.4;\n            var kr = (n_u - n) / (n_u - n_bal) < 1 ? (n_u - n) / (n_u - n_bal) : 1;\n\n            // K_phi\n            var lambda = this.l0 / this.i;\n            var beta = 0.35 + this.fck / 200 - lambda / 150;\n            var phi_eff = 2.5;\n            var k_phi = 1 + beta * phi_eff;\n\n            var d = 0.8 * Math.sqrt(area); // only with squares.\n            var _1_div_r0 = eps_yd / (0.45 * d);\n            var _1_div_r = kr * k_phi * _1_div_r0;\n            var e2 = _1_div_r * Math.pow(this.l0, 2) / Math.pow(Math.PI, 2);\n            var M2 = -this.ned * e2;\n            return { \"M2\": M2 };\n        }\n    }, {\n        key: \"axialForceResistance\",\n        value: function axialForceResistance(area) {\n            return area * this.fck / 1.5 + area * this.rho * _mnkappa.B500.det_stress(1.75);\n        }\n    }]);\n\n    return ColumnNENEN;\n}();\n\nexports.default = ColumnNENEN;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvY29sdW1uX25lbl9lbi5qcz9hZWE3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHtyZWN0YW5nbGUsIG1fbl9rYXBwYSwgQjUwMCwgZGlhZ3JhbU5vQ29uY3JldGVUZW5zaW9uLCBkaWFncmFtQ29uY3JldGVCaUxpbmVhclVMUyxcbmNhbGNIb29rdXB9IGZyb20gXCIuL21ua2FwcGEuanNcIlxubGV0IHZhbmlsbGEgPSByZXF1aXJlKFwiLi92YW5pbGxhX21rYXAubWluLmpzXCIpO1xuXG5jb25zdCBmeWQgPSA0MzU7XG5jb25zdCBlcHNfeWQgPSBmeWQgLyAyZTU7XG5cbmZ1bmN0aW9uIGRldE0wZShtMSwgbTIpIHtcbiAgICAvKlxuICAgICAqIERldGVybWluZSBNMGUgY29uZm9ybSBORU4tRU4gMTk5Mi0xLTEgYXJ0LiA1LjguOC4yKDIpLlxuICAgICAqXG4gICAgICogQHBhcmFtIG0xOiAoZmxvYXQpIEJlbmRpbmcgbW9tZW50IGF0IHRvcCBvciBib3R0b20gb2YgY29sdW1uLlxuICAgICAqIEBwYXJhbSBtMjogKGZsb2F0KSBCZW5kaW5nIG1vbWVudCBhdCB0b3Agb3IgYm90dG9tIG9mIGNvbHVtbi5cbiAgICAgKiAqL1xuICAgIGxldCBtMDIgPSBNYXRoLm1heChtMSwgbTIpO1xuICAgIGxldCBtMDEgPSBNYXRoLm1pbihtMSwgbTIpO1xuICAgIGxldCBtMGUgPSAwLjYgKiBtMDIgKyAwLjQgKiBtMDE7XG4gICAgcmV0dXJuIG0wZSA+IDAuNCAqIG0wMiA/IG0wZSA6IDAuNCAqIG0wZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29sdW1uTkVORU4ge1xuICAgIC8qXG4gICAgICogQ29tcHV0ZSB0aGUgbWluaW11bSByZXF1aXJlZCBjb2x1bW4gZGltZW5zaW9uIGNvbmZvcm0gTkVOLUVOLlxuICAgICAqIFVuaXRzOlxuICAgICAqICBOXG4gICAgICogIG1tXG4gICAgICogICVcbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG0xLCBtMiwgbmVkLCBmY2ssIHJobywgbDApIHtcbiAgICAgICAgdGhpcy5tMSA9IG0xO1xuICAgICAgICB0aGlzLm0yID0gbTI7XG4gICAgICAgIHRoaXMubmVkID0gbmVkO1xuICAgICAgICB0aGlzLmZjayA9IGZjaztcbiAgICAgICAgdGhpcy5yaG8gPSByaG87XG4gICAgICAgIHRoaXMubDAgPSBsMDtcbiAgICAgICAgdGhpcy5tMGVkID0gZGV0TTBlKG0xLCBtMik7XG5cbiAgICAgICAgdGhpcy5pID0gMDsgLy8gbmVlZHMgdG8gYmUgZGV0ZXJtaW5lZCBiZWZvcmUgZGV0IHBhcmFtc1xuXG4gICAgICAgIC8vIHJlc3VsdHNcbiAgICAgICAgdGhpcy52YWxpZGl0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLndpZHRoID0gbnVsbDtcbiAgICAgICAgdGhpcy5BcyA9IG51bGxcbiAgICB9XG5cbiAgICBkZXRfcGFyYW1zKGFyZWEpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogRGV0ZXJtaW5lIHRoZSBORU4tRU4gcGFyYW1ldGVycy4gQWxsIHRoZSBwYXJhbWV0ZXJzIGFyZSByZXF1aXJlZCB0byBkZXRlcm1pbmUgTTIuIFRoZXNlIGFyZSBhc3NpZ25lZCBmb3JcbiAgICAgICAgICogcmVhZGFiaWxpdHkuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICAvLyBLclxuICAgICAgICBsZXQgbiA9IHRoaXMubmVkIC8gKGFyZWEgKiB0aGlzLmZjayAvIDEuNSk7XG4gICAgICAgIHRoaXMuYXMgPSBhcmVhICogdGhpcy5yaG87XG4gICAgICAgIHRoaXMub21lZ2EgPSB0aGlzLmFzICogZnlkIC8gKGFyZWEgKiB0aGlzLmZjayAvIDEuNSk7XG4gICAgICAgIGxldCBuX3U9IDEgKyB0aGlzLm9tZWdhO1xuICAgICAgICBsZXQgbl9iYWwgPSAwLjQ7XG4gICAgICAgIGxldCBrciA9IChuX3UgLSBuKSAvIChuX3UgLSBuX2JhbCkgPCAxID8gKG5fdSAtIG4pIC8gKG5fdSAtIG5fYmFsKSA6IDE7XG5cbiAgICAgICAgLy8gS19waGlcbiAgICAgICAgbGV0IGxhbWJkYSA9IHRoaXMubDAgLyB0aGlzLmk7XG4gICAgICAgIGxldCBiZXRhID0gMC4zNSArIHRoaXMuZmNrIC8gMjAwIC0gbGFtYmRhIC8gMTUwO1xuICAgICAgICBsZXQgcGhpX2VmZiA9IDIuNTtcbiAgICAgICAgbGV0IGtfcGhpID0gMSArIGJldGEgKiBwaGlfZWZmO1xuXG4gICAgICAgIGxldCBkID0gMC44ICogTWF0aC5zcXJ0KGFyZWEpOyAvLyBvbmx5IHdpdGggc3F1YXJlcy5cbiAgICAgICAgbGV0IF8xX2Rpdl9yMCA9IGVwc195ZCAvICgwLjQ1ICogZCk7XG4gICAgICAgIGxldCBfMV9kaXZfciA9IGtyICoga19waGkgKiBfMV9kaXZfcjA7XG4gICAgICAgIGxldCBlMiA9IF8xX2Rpdl9yICogTWF0aC5wb3codGhpcy5sMCwgMikgLyBNYXRoLnBvdyhNYXRoLlBJLCAyKTtcbiAgICAgICAgbGV0IE0yID0gLXRoaXMubmVkICogZTI7XG4gICAgICAgIHJldHVybiB7XCJNMlwiOiBNMn1cbiAgICB9XG5cbiAgICBzb2x2ZSA9ICgpID0+IHtcbiAgICAgICAgLypcbiAgICAgICAgICogU29sdmUgZm9yIHRoZSBtaW5pbXVtIHJlcXVpcmVkIGRpbWVuc2lvbnMuIEZpcnN0IGZvciBOZWQuIElmIHdpdGggdGhlc2UgZGltZW5zaW9ucyBNZWQgPiBNcmQsIGRldGVybWluZVxuICAgICAgICAgKiB0aGUgZGltZW5zaW9uIGJhc2VkIG9uIE1lZC5cbiAgICAgICAgICovXG4gICAgICAgIGxldCBmY2QgPSB0aGlzLmZjayAvIDEuNTtcbiAgICAgICAgbGV0IGZjID0gZGlhZ3JhbUNvbmNyZXRlQmlMaW5lYXJVTFMoZmNkKTtcbiAgICAgICAgbGV0IGIgPSAxMDAwO1xuICAgICAgICBsZXQgYyA9IDA7XG4gICAgICAgIGxldCBhcmVhO1xuICAgICAgICBsZXQgbTtcbiAgICAgICAgbGV0IGFzO1xuICAgICAgICBsZXQgbnJkO1xuXG4gICAgICAgIGxldCBhc3NpZ24gPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkaXR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBiO1xuICAgICAgICAgICAgdGhpcy5BcyA9IGFzO1xuICAgICAgICAgICAgdGhpcy5tcmQgPSBtLm1vbWVudDtcbiAgICAgICAgICAgIHRoaXMubnJkID0gbnJkXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB0aGUgbWluaW11bSByZXF1aXJlZCBkaW1lbnNpb24gZm9yIHRoZSBheGlhbCBmb3JjZS5cbiAgICAgICAgd2hpbGUodHJ1ZSkge1xuICAgICAgICAgICAgYXJlYSA9IE1hdGgucG93KGIsIDIpO1xuICAgICAgICAgICAgbnJkID0gdGhpcy5heGlhbEZvcmNlUmVzaXN0YW5jZShhcmVhKTtcbiAgICAgICAgICAgIGlmICh2YW5pbGxhLnN0ZC5jb252ZXJnZW5jZV9jb25kaXRpb25zKG5yZCwgLXRoaXMubmVkLCAxLjAxLCAwLjk5KSkge1xuICAgICAgICAgICAgICAgIGFzID0gdGhpcy5yaG8gKiBhcmVhIC8gMjtcbiAgICAgICAgICAgICAgICBsZXQgY3MgPSByZWN0YW5nbGUoYiwgYik7XG4gICAgICAgICAgICAgICAgbSA9IG1fbl9rYXBwYShjcywgZmMsIGRpYWdyYW1Ob0NvbmNyZXRlVGVuc2lvbiwgQjUwMCwgW2FzLCBhc10sIFswLjIgKiBiLCAwLjggKiBiXSAsIHRoaXMubmVkKTtcbiAgICAgICAgICAgICAgICBjYWxjSG9va3VwKDAuMDUsIG0pO1xuICAgICAgICAgICAgICAgIG0uZGV0X21fa2FwcGEoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbnZlcmdlbmNlXCIsIG0ubW9tZW50IC8gMWU2LCBcImNvdW50XCIsIGMpO1xuICAgICAgICAgICAgICAgIGFzc2lnbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiICo9IHZhbmlsbGEuc3RkLmNvbnZlcmdlbmNlKG5yZCwgLXRoaXMubmVkKTtcbiAgICAgICAgICAgIGMrKztcblxuICAgICAgICAgICAgaWYgKGMgPiAyMDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkYXRlIGlmIHRoZSB0aGUgbWluaW11bSByZXF1aXJlZCBjcm9zcyBzZWN0aW9uIGZvciB0aGUgYXhpYWwgZm9yY2UgaXMgYWJsZSB0byBiZWFyIHRoZSB0b3RhbCBtb21lbnQuXG4gICAgICAgIHRoaXMuaSA9IGIgLyAzLjQ2O1xuICAgICAgICBsZXQgTTIgPSB0aGlzLmRldF9wYXJhbXMoYXJlYSkuTTI7XG4gICAgICAgIGxldCBNMEVkTTIgPSBNYXRoLm1heCh0aGlzLm0wZWQgKyBNMiwgdGhpcy5tMiwgdGhpcy5tMSArIDAuNSAqIE0yKTtcbiAgICAgICAgaWYgKG0ubW9tZW50ID4gTTBFZE0yKSB7ICAvLyBUaGUgY3Jvc3Mgc2VjdGlvbiBpcyBzdWZmaWNpZW50LlxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJNaW5pbWFsIGF4aWFsIGZvcmNlIGlzIHN1ZmZpY2llbnRcIilcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGMgPSAwO1xuXG4gICAgICAgICAgICB3aGlsZSh0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pID0gYiAvIDMuNDY7XG4gICAgICAgICAgICAgICAgYXJlYSA9IE1hdGgucG93KGIsIDIpO1xuICAgICAgICAgICAgICAgIGFzID0gdGhpcy5yaG8gKiBhcmVhIC8gMjtcbiAgICAgICAgICAgICAgICBsZXQgY3MgPSByZWN0YW5nbGUoYiwgYik7XG5cbiAgICAgICAgICAgICAgICBtID0gbV9uX2thcHBhKGNzLCBmYywgZGlhZ3JhbU5vQ29uY3JldGVUZW5zaW9uLCBCNTAwLCBbYXMsIGFzXSwgWzAuMiAqIGIsIDAuOCAqIGJdICwgdGhpcy5uZWQpO1xuICAgICAgICAgICAgICAgIGNhbGNIb29rdXAoMC4wNSwgbSk7XG4gICAgICAgICAgICAgICAgbS5kZXRfbV9rYXBwYSgpO1xuXG4gICAgICAgICAgICAgICAgbGV0IE0yID0gdGhpcy5kZXRfcGFyYW1zKGFyZWEpLk0yO1xuICAgICAgICAgICAgICAgIGxldCBNMEVkTTIgPSBNYXRoLm1heCh0aGlzLm0wZWQgKyBNMiwgdGhpcy5tMiwgdGhpcy5tMSArIDAuNSAqIE0yKTtcblxuICAgICAgICAgICAgICAgIGxldCBmYWN0b3IgPSB2YW5pbGxhLnN0ZC5jb252ZXJnZW5jZShtLm1vbWVudCwgTTBFZE0yLCA0KTtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiZmFjdG9yOiBcIiwgZmFjdG9yKTtcbiAgICAgICAgICAgICAgICBiICo9IGZhY3RvcjtcblxuICAgICAgICAgICAgICAgIC8vIGlmICh0aGlzLmF4aWFsRm9yY2VSZXNpc3RhbmNlKGFyZWEpIDwgLXRoaXMubmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKHZhbmlsbGEuc3RkLmNvbnZlcmdlbmNlKHRoaXMuYXhpYWxGb3JjZVJlc2lzdGFuY2UoYXJlYSksIC10aGlzLm5lZCksIHRoaXMuYXhpYWxGb3JjZVJlc2lzdGFuY2UoYXJlYSkvMWUzKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgY29uc29sZS5sb2coXCJtaW5pbWFsIGF4aWFsIGZvcmNlIGRpbWVuc2lvblwiKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgICAgICBpZiAodmFuaWxsYS5zdGQuY29udmVyZ2VuY2VfY29uZGl0aW9ucyhNMEVkTTIsIG0ubW9tZW50LCAxLjAxLCAwLjk5KSAmJiBtLnZhbGlkaXR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb252ZXJnZW5jZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKE0wRWRNMiwgbS5tb21lbnQsIG0udmFsaWRpdHkoKSwgYik7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsaWRpdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJicmVha1wiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYysrO1xuXG4gICAgICAgICAgICAgICAgaWYgKGMgPiAyNTApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWxpZGl0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIm1heCBpdGVyXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBheGlhbEZvcmNlUmVzaXN0YW5jZShhcmVhKSB7XG4gICAgICAgIHJldHVybiBhcmVhICogdGhpcy5mY2sgLyAxLjUgKyBhcmVhICogdGhpcy5yaG8gKiBCNTAwLmRldF9zdHJlc3MoMS43NSlcbiAgICB9XG5cbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9jb2x1bW5fbmVuX2VuLmpzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7Ozs7O0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBOENBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBd0dBO0FBQ0E7QUFDQTs7Ozs7O0FBOUpBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 2 */
/* unknown exports provided */
/* all exports used */
/*!************************!*\
  !*** ./src/mnkappa.js ***!
  \************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar vanilla = __webpack_require__(/*! ./vanilla_mkap.min.js */ 0);\n\nfunction rectangle(b, h) {\n    /**\n    * Create a cross section required for the M-N-Kappa solver.\n    *\n    * @param a: (float) Width of the cross section\n    * @param b: (float) Height of the cross section\n    * */\n\n    var pg = [[0, 0], [0, b], [h, b], [h, 0], [0, 0]];\n\n    for (var i in pg) {\n        pg[i] = new vanilla.vector.Point(pg[i][0], pg[i][1]);\n    }\n    return new vanilla.crsn.PolyGon(pg);\n}\n\nfunction m_n_kappa(cs, fc, fct, fs, as, z, ned) {\n    /**\n    * Prepare a m_n_kappa instance.\n    *\n    * @param cs: (Polygon)\n    * @param fc: (StressStrain) Concrete compressive stress strain diagram.\n    * @param fct: (StressStrain) Concrete tensile stress strain diagram.\n    * @param fs: (StressStrain) Reinforcement stress strain diagram.\n    * @param as: (Array) Array with area values of the reinforcement.\n    * @param z: (Array) Distance of the reinforcement from the bottom of the cross section.\n    * @param ned: (float) Axial force value.\n    *\n    * @returns moment kappa instance\n    * */\n\n    var m = new vanilla.mkap.MomentKappa(cs, fc, fct);\n    m.instantiate_standard_reinforcement(as, z, fs);\n    m.normal_force = ned;\n\n    return m;\n}\n\nfunction diagramConcreteBiLinearULS(stress) {\n    return new vanilla.mkap.StressStrain([0, 1.75, 3.5], [0, stress, stress]);\n}\n\nvar diagramNoConcreteTension = new vanilla.mkap.StressStrain([0, 0], [0, 0]);\nvar B500 = new vanilla.mkap.StressStrain([0, 2.175, 25], [0, 435, 435]);\nvar calcHookup = vanilla.mkap.calcHookup;\n\nexports.rectangle = rectangle;\nexports.m_n_kappa = m_n_kappa;\nexports.diagramConcreteBiLinearULS = diagramConcreteBiLinearULS;\nexports.B500 = B500;\nexports.diagramNoConcreteTension = diagramNoConcreteTension;\nexports.calcHookup = calcHookup;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvbW5rYXBwYS5qcz81OWE3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubGV0IHZhbmlsbGEgPSByZXF1aXJlKFwiLi92YW5pbGxhX21rYXAubWluLmpzXCIpO1xuXG5mdW5jdGlvbiByZWN0YW5nbGUoYiwgaCkge1xuICAgIC8qKlxuICAgICogQ3JlYXRlIGEgY3Jvc3Mgc2VjdGlvbiByZXF1aXJlZCBmb3IgdGhlIE0tTi1LYXBwYSBzb2x2ZXIuXG4gICAgKlxuICAgICogQHBhcmFtIGE6IChmbG9hdCkgV2lkdGggb2YgdGhlIGNyb3NzIHNlY3Rpb25cbiAgICAqIEBwYXJhbSBiOiAoZmxvYXQpIEhlaWdodCBvZiB0aGUgY3Jvc3Mgc2VjdGlvblxuICAgICogKi9cblxuICAgIGxldCBwZyA9IFtbMCwgMF0sIFswLCBiXSwgW2gsIGJdLCBbaCwgMF0sIFswLCAwXV07XG5cbiAgICBmb3IgKGxldCBpIGluIHBnKSB7XG4gICAgICAgIHBnW2ldID0gbmV3IHZhbmlsbGEudmVjdG9yLlBvaW50KHBnW2ldWzBdLCBwZ1tpXVsxXSlcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB2YW5pbGxhLmNyc24uUG9seUdvbihwZylcbn1cblxuZnVuY3Rpb24gbV9uX2thcHBhKGNzLCBmYywgZmN0LCBmcywgYXMsIHosIG5lZCkge1xuICAgIC8qKlxuICAgICogUHJlcGFyZSBhIG1fbl9rYXBwYSBpbnN0YW5jZS5cbiAgICAqXG4gICAgKiBAcGFyYW0gY3M6IChQb2x5Z29uKVxuICAgICogQHBhcmFtIGZjOiAoU3RyZXNzU3RyYWluKSBDb25jcmV0ZSBjb21wcmVzc2l2ZSBzdHJlc3Mgc3RyYWluIGRpYWdyYW0uXG4gICAgKiBAcGFyYW0gZmN0OiAoU3RyZXNzU3RyYWluKSBDb25jcmV0ZSB0ZW5zaWxlIHN0cmVzcyBzdHJhaW4gZGlhZ3JhbS5cbiAgICAqIEBwYXJhbSBmczogKFN0cmVzc1N0cmFpbikgUmVpbmZvcmNlbWVudCBzdHJlc3Mgc3RyYWluIGRpYWdyYW0uXG4gICAgKiBAcGFyYW0gYXM6IChBcnJheSkgQXJyYXkgd2l0aCBhcmVhIHZhbHVlcyBvZiB0aGUgcmVpbmZvcmNlbWVudC5cbiAgICAqIEBwYXJhbSB6OiAoQXJyYXkpIERpc3RhbmNlIG9mIHRoZSByZWluZm9yY2VtZW50IGZyb20gdGhlIGJvdHRvbSBvZiB0aGUgY3Jvc3Mgc2VjdGlvbi5cbiAgICAqIEBwYXJhbSBuZWQ6IChmbG9hdCkgQXhpYWwgZm9yY2UgdmFsdWUuXG4gICAgKlxuICAgICogQHJldHVybnMgbW9tZW50IGthcHBhIGluc3RhbmNlXG4gICAgKiAqL1xuXG4gICAgbGV0IG0gPSBuZXcgdmFuaWxsYS5ta2FwLk1vbWVudEthcHBhKGNzLCBmYywgZmN0KTtcbiAgICBtLmluc3RhbnRpYXRlX3N0YW5kYXJkX3JlaW5mb3JjZW1lbnQoYXMsIHosIGZzKTtcbiAgICBtLm5vcm1hbF9mb3JjZSA9IG5lZDtcblxuICAgIHJldHVybiBtXG59XG5cblxuZnVuY3Rpb24gZGlhZ3JhbUNvbmNyZXRlQmlMaW5lYXJVTFMoc3RyZXNzKSB7XG4gICAgcmV0dXJuIG5ldyB2YW5pbGxhLm1rYXAuU3RyZXNzU3RyYWluKFswLCAxLjc1LCAzLjVdLCBbMCwgc3RyZXNzLCBzdHJlc3NdKVxufVxuXG5jb25zdCBkaWFncmFtTm9Db25jcmV0ZVRlbnNpb24gPSBuZXcgdmFuaWxsYS5ta2FwLlN0cmVzc1N0cmFpbihbMCwgMF0sIFswLCAwXSk7XG5jb25zdCBCNTAwID0gbmV3IHZhbmlsbGEubWthcC5TdHJlc3NTdHJhaW4oWzAsIDIuMTc1LCAyNV0sIFswLCA0MzUsIDQzNV0pO1xubGV0IGNhbGNIb29rdXAgPSB2YW5pbGxhLm1rYXAuY2FsY0hvb2t1cDtcblxuZXhwb3J0IHtyZWN0YW5nbGUsIG1fbl9rYXBwYSwgZGlhZ3JhbUNvbmNyZXRlQmlMaW5lYXJVTFMsIEI1MDAsIGRpYWdyYW1Ob0NvbmNyZXRlVGVuc2lvbiwgY2FsY0hvb2t1cH1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL21ua2FwcGEuanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 3 */
/* unknown exports provided */
/* all exports used */
/*!****************************************!*\
  !*** ./~/babel-loader!./src/worker.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _column_nen_en = __webpack_require__(/*! ./column_nen_en.js */ 1);\n\nvar _column_nen_en2 = _interopRequireDefault(_column_nen_en);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Method that accepts the PostMessage event\nonmessage = function onmessage(e) {\n    console.log(\"Starting calculation on worker\");\n    var calc = new _column_nen_en2.default(e.data.M1 * 1e6, e.data.M2 * 1e6, e.data.Ned * 1e3 * e.data.UC, e.data.concrete, e.data.rho / 1e2, e.data.l0 * 1e3);\n    calc.solve();\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvd29ya2VyLmpzPzViZmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvbHVtbk5FTkVOIGZyb20gXCIuL2NvbHVtbl9uZW5fZW4uanNcIlxuXG4vLyBNZXRob2QgdGhhdCBhY2NlcHRzIHRoZSBQb3N0TWVzc2FnZSBldmVudFxub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICBjb25zb2xlLmxvZyhcIlN0YXJ0aW5nIGNhbGN1bGF0aW9uIG9uIHdvcmtlclwiKVxuICAgIGxldCBjYWxjID0gbmV3IENvbHVtbk5FTkVOKGUuZGF0YS5NMSAqIDFlNiwgZS5kYXRhLk0yICogMWU2LCBlLmRhdGEuTmVkICogMWUzICogZS5kYXRhLlVDLCBlLmRhdGEuY29uY3JldGUsXG4gICAgICAgIGUuZGF0YS5yaG8gLyAxZTIsIGUuZGF0YS5sMCAqIDFlMyk7XG4gICAgY2FsYy5zb2x2ZSgpO1xuXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy93b3JrZXIuanMiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ })
/******/ ]);